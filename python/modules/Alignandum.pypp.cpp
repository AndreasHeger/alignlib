// This file has been generated by Py++.

#include "boost/python.hpp"
#include "includes.h"
#include "iostream"
#include "cstdio"
#include "streambuf"
#include "Alignandum.pypp.hpp"

namespace bp = boost::python;

class std_obuf: public std::streambuf 
        {
      public:
        std_obuf(std::FILE* file): m_file(file) {}
      protected:
        std::streambuf::int_type overflow(std::streambuf::int_type c) 
        {
          return std::fputc(c, m_file) ==EOF? std::streambuf::traits_type::eof(): c;
        }
      private:
        FILE* m_file;
      };

    class std_ibuf: public std::streambuf 
        {
      public:
          std_ibuf(std::FILE* file): m_file(file) {}
      protected:
          std::streambuf::int_type underflow() { 
           int c = std::getc(m_file);
           if (c != EOF) 
               std::ungetc(c, m_file);
            return c;
           }

          std::streambuf::int_type uflow() {
           return std::getc(m_file);
          }

          std::streambuf::int_type pbackfail(int c = EOF) {
            return c != EOF ? std::ungetc(c, m_file) : EOF;
          }
    private:
          FILE* m_file;      
          
      };

template<class T>
      void wrapper_for_save(const T & a, PyObject* fp) 
      {
        if (!PyFile_Check(fp)) 
        {
          throw boost::python::error_already_set();
        }
        std::FILE* f = PyFile_AsFile(fp);
        std_obuf buf(f);
        std::ostream os(&buf);
        a.save( os );
      }

void register_Alignandum_class(){

    { //::alignlib::Alignandum
        typedef bp::class_< alignlib::Alignandum, bp::bases< alignlib::AlignlibBase >, boost::noncopyable > Alignandum_exposer_t;
        Alignandum_exposer_t Alignandum_exposer = Alignandum_exposer_t( "Alignandum", bp::no_init );
        bp::scope Alignandum_scope( Alignandum_exposer );
        { //::alignlib::Alignandum::asChar
        
            typedef char ( ::alignlib::Alignandum::*asChar_function_type )( ::alignlib::Position ) const;
            
            Alignandum_exposer.def( 
                "asChar"
                , asChar_function_type( &::alignlib::Alignandum::asChar )
                , ( bp::arg("pos") ) );
        
        }
        { //::alignlib::Alignandum::asResidue
        
            typedef ::alignlib::Residue ( ::alignlib::Alignandum::*asResidue_function_type )( ::alignlib::Position ) const;
            
            Alignandum_exposer.def( 
                "asResidue"
                , asResidue_function_type( &::alignlib::Alignandum::asResidue )
                , ( bp::arg("pos") ) );
        
        }
        { //::alignlib::Alignandum::asString
        
            typedef ::std::string ( ::alignlib::Alignandum::*asString_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "asString"
                , asString_function_type( &::alignlib::Alignandum::asString ) );
        
        }
        { //::alignlib::Alignandum::getClone
        
            typedef ::alignlib::HAlignandum ( ::alignlib::Alignandum::*getClone_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::Alignandum::getClone ) );
        
        }
        { //::alignlib::Alignandum::getFrom
        
            typedef ::alignlib::Position ( ::alignlib::Alignandum::*getFrom_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getFrom"
                , getFrom_function_type( &::alignlib::Alignandum::getFrom ) );
        
        }
        { //::alignlib::Alignandum::getFullLength
        
            typedef ::alignlib::Position ( ::alignlib::Alignandum::*getFullLength_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getFullLength"
                , getFullLength_function_type( &::alignlib::Alignandum::getFullLength ) );
        
        }
        { //::alignlib::Alignandum::getLength
        
            typedef ::alignlib::Position ( ::alignlib::Alignandum::*getLength_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getLength"
                , getLength_function_type( &::alignlib::Alignandum::getLength ) );
        
        }
        { //::alignlib::Alignandum::getNew
        
            typedef ::alignlib::HAlignandum ( ::alignlib::Alignandum::*getNew_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getNew"
                , getNew_function_type( &::alignlib::Alignandum::getNew ) );
        
        }
        { //::alignlib::Alignandum::getStorageType
        
            typedef ::alignlib::StorageType ( ::alignlib::Alignandum::*getStorageType_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getStorageType"
                , getStorageType_function_type( &::alignlib::Alignandum::getStorageType ) );
        
        }
        { //::alignlib::Alignandum::getTo
        
            typedef ::alignlib::Position ( ::alignlib::Alignandum::*getTo_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getTo"
                , getTo_function_type( &::alignlib::Alignandum::getTo ) );
        
        }
        { //::alignlib::Alignandum::isMasked
        
            typedef bool ( ::alignlib::Alignandum::*isMasked_function_type )( ::alignlib::Position const & ) const;
            
            Alignandum_exposer.def( 
                "isMasked"
                , isMasked_function_type( &::alignlib::Alignandum::isMasked )
                , ( bp::arg("pos") ) );
        
        }
        { //::alignlib::Alignandum::isPrepared
        
            typedef bool ( ::alignlib::Alignandum::*isPrepared_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "isPrepared"
                , isPrepared_function_type( &::alignlib::Alignandum::isPrepared ) );
        
        }
        { //::alignlib::Alignandum::mask
        
            typedef void ( ::alignlib::Alignandum::*mask_function_type )( ::alignlib::Position const &,::alignlib::Position const & ) ;
            
            Alignandum_exposer.def( 
                "mask"
                , mask_function_type( &::alignlib::Alignandum::mask )
                , ( bp::arg("from"), bp::arg("to")=-0x00000000000000001 ) );
        
        }
        { //::alignlib::Alignandum::prepare
        
            typedef void ( ::alignlib::Alignandum::*prepare_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "prepare"
                , prepare_function_type( &::alignlib::Alignandum::prepare ) );
        
        }
        { //::alignlib::Alignandum::release
        
            typedef void ( ::alignlib::Alignandum::*release_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "release"
                , release_function_type( &::alignlib::Alignandum::release ) );
        
        }
        { //::alignlib::Alignandum::setStorageType
        
            typedef void ( ::alignlib::Alignandum::*setStorageType_function_type )( ::alignlib::StorageType const & ) ;
            
            Alignandum_exposer.def( 
                "setStorageType"
                , setStorageType_function_type( &::alignlib::Alignandum::setStorageType )
                , ( bp::arg("storage_type") ) );
        
        }
        { //::alignlib::Alignandum::shuffle
        
            typedef void ( ::alignlib::Alignandum::*shuffle_function_type )( unsigned int,::alignlib::Position ) ;
            
            Alignandum_exposer.def( 
                "shuffle"
                , shuffle_function_type( &::alignlib::Alignandum::shuffle )
                , ( bp::arg("num_iterations")=(unsigned int)(1), bp::arg("window_size")=(int)(0) ) );
        
        }
        { //::alignlib::Alignandum::swap
        
            typedef void ( ::alignlib::Alignandum::*swap_function_type )( ::alignlib::Position const &,::alignlib::Position const & ) ;
            
            Alignandum_exposer.def( 
                "swap"
                , swap_function_type( &::alignlib::Alignandum::swap )
                , ( bp::arg("x"), bp::arg("y") ) );
        
        }
        { //::alignlib::Alignandum::useSegment
        
            typedef void ( ::alignlib::Alignandum::*useSegment_function_type )( ::alignlib::Position,::alignlib::Position ) ;
            
            Alignandum_exposer.def( 
                "useSegment"
                , useSegment_function_type( &::alignlib::Alignandum::useSegment )
                , ( bp::arg("from")=(int)(-0x00000000000000001), bp::arg("to")=(int)(-0x00000000000000001) ) );
        
        }
        { //::alignlib::Alignandum::write
        
            typedef void ( ::alignlib::Alignandum::*write_function_type )( ::std::ostream & ) const;
            
            Alignandum_exposer.def( 
                "write"
                , write_function_type( &::alignlib::Alignandum::write )
                , ( bp::arg("output") ) );
        
        }
        Alignandum_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Alignandum > >();
        bp::implicitly_convertible< boost::shared_ptr< alignlib::Alignandum >, boost::shared_ptr< alignlib::AlignlibBase > >();
        bp::implicitly_convertible< boost::shared_ptr< alignlib::Profile >, boost::shared_ptr< alignlib::Alignandum > >();
        bp::implicitly_convertible< boost::shared_ptr< alignlib::Sequence >, boost::shared_ptr< alignlib::Alignandum > >();
        Alignandum_exposer.def( "save", wrapper_for_save<alignlib::Alignandum> );
    }

}
