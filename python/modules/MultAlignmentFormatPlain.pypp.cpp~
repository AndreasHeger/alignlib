// This file has been generated by Py++.

#include "boost/python.hpp"
#include "includes.h"
#include "iostream"
#include "cstdio"
#include "MultAlignmentFormatPlain.pypp.hpp"

namespace bp = boost::python;

struct MultAlignmentFormatPlain_wrapper : alignlib::MultAlignmentFormatPlain, bp::wrapper< alignlib::MultAlignmentFormatPlain > {

    MultAlignmentFormatPlain_wrapper( )
    : alignlib::MultAlignmentFormatPlain( )
      , bp::wrapper< alignlib::MultAlignmentFormatPlain >(){
        // null constructor
    
    }

    MultAlignmentFormatPlain_wrapper(::alignlib::HMultAlignment const & src, ::alignlib::HStringVector const & sequences )
    : alignlib::MultAlignmentFormatPlain( src, sequences )
      , bp::wrapper< alignlib::MultAlignmentFormatPlain >(){
        // constructor
    
    }

    MultAlignmentFormatPlain_wrapper(::std::istream & src )
    : alignlib::MultAlignmentFormatPlain( boost::ref(src) )
      , bp::wrapper< alignlib::MultAlignmentFormatPlain >(){
        // constructor
    
    }

    MultAlignmentFormatPlain_wrapper(::std::string const & src )
    : alignlib::MultAlignmentFormatPlain( src )
      , bp::wrapper< alignlib::MultAlignmentFormatPlain >(){
        // constructor
    
    }

    MultAlignmentFormatPlain_wrapper(::alignlib::MultAlignmentFormatPlain const & arg0 )
    : alignlib::MultAlignmentFormatPlain( boost::ref(arg0) )
      , bp::wrapper< alignlib::MultAlignmentFormatPlain >(){
        // copy constructor
    
    }

    virtual void fill( ::alignlib::HMultAlignment const & src, ::alignlib::HStringVector const & sequences ) {
        if( bp::override func_fill = this->get_override( "fill" ) )
            func_fill( src, sequences );
        else
            this->alignlib::MultAlignmentFormatPlain::fill( src, sequences );
    }
    
    
    void default_fill( ::alignlib::HMultAlignment const & src, ::alignlib::HStringVector const & sequences ) {
        alignlib::MultAlignmentFormatPlain::fill( src, sequences );
    }

    virtual void load( ::std::istream & arg0 ) {
        if( bp::override func_load = this->get_override( "load" ) )
            func_load( boost::ref(arg0) );
        else
            this->alignlib::MultAlignmentFormatPlain::load( boost::ref(arg0) );
    }
    
    
    void default_load( ::std::istream & arg0 ) {
        alignlib::MultAlignmentFormatPlain::load( boost::ref(arg0) );
    }

    virtual void save( ::std::ostream & arg0 ) const  {
        if( bp::override func_save = this->get_override( "save" ) )
            func_save( boost::ref(arg0) );
        else
            this->alignlib::MultAlignmentFormatPlain::save( boost::ref(arg0) );
    }
    
    
    void default_save( ::std::ostream & arg0 ) const  {
        alignlib::MultAlignmentFormatPlain::save( boost::ref(arg0) );
    }

};

void register_MultAlignmentFormatPlain_class(){

    { //::alignlib::MultAlignmentFormatPlain
        typedef bp::class_< MultAlignmentFormatPlain_wrapper > MultAlignmentFormatPlain_exposer_t;
        MultAlignmentFormatPlain_exposer_t MultAlignmentFormatPlain_exposer = MultAlignmentFormatPlain_exposer_t( "MultAlignmentFormatPlain", bp::init< >() );
        bp::scope MultAlignmentFormatPlain_scope( MultAlignmentFormatPlain_exposer );
        MultAlignmentFormatPlain_exposer.def( bp::init< alignlib::HMultAlignment const &, alignlib::HStringVector const & >(( bp::arg("src"), bp::arg("sequences") )) );
        MultAlignmentFormatPlain_exposer.def( bp::init< std::istream & >(( bp::arg("src") )) );
        bp::implicitly_convertible< std::istream &, alignlib::MultAlignmentFormatPlain >();
        MultAlignmentFormatPlain_exposer.def( bp::init< std::string const & >(( bp::arg("src") )) );
        bp::implicitly_convertible< std::string const &, alignlib::MultAlignmentFormatPlain >();
        MultAlignmentFormatPlain_exposer.def( bp::init< alignlib::MultAlignmentFormatPlain const & >(( bp::arg("arg0") )) );
        { //::alignlib::MultAlignmentFormatPlain::fill
        
            typedef void ( ::alignlib::MultAlignmentFormatPlain::*fill_function_type )( ::alignlib::HMultAlignment const &,::alignlib::HStringVector const & ) ;
            typedef void ( MultAlignmentFormatPlain_wrapper::*default_fill_function_type )( ::alignlib::HMultAlignment const &,::alignlib::HStringVector const & ) ;
            
            MultAlignmentFormatPlain_exposer.def( 
                "fill"
                , fill_function_type(&::alignlib::MultAlignmentFormatPlain::fill)
                , default_fill_function_type(&MultAlignmentFormatPlain_wrapper::default_fill)
                , ( bp::arg("src"), bp::arg("sequences") ) );
        
        }
        { //::alignlib::MultAlignmentFormatPlain::load
        
            typedef void ( ::alignlib::MultAlignmentFormatPlain::*load_function_type )( ::std::istream & ) ;
            typedef void ( MultAlignmentFormatPlain_wrapper::*default_load_function_type )( ::std::istream & ) ;
            
            MultAlignmentFormatPlain_exposer.def( 
                "load"
                , load_function_type(&::alignlib::MultAlignmentFormatPlain::load)
                , default_load_function_type(&MultAlignmentFormatPlain_wrapper::default_load)
                , ( bp::arg("arg0") ) );
        
        }
        { //::alignlib::MultAlignmentFormatPlain::save
        
            typedef void ( ::alignlib::MultAlignmentFormatPlain::*save_function_type )( ::std::ostream & ) const;
            typedef void ( MultAlignmentFormatPlain_wrapper::*default_save_function_type )( ::std::ostream & ) const;
            
            MultAlignmentFormatPlain_exposer.def( 
                "save"
                , save_function_type(&::alignlib::MultAlignmentFormatPlain::save)
                , default_save_function_type(&MultAlignmentFormatPlain_wrapper::default_save)
                , ( bp::arg("arg0") ) );
        
        }
        MultAlignmentFormatPlain_exposer.def( bp::self_ns::str( bp::self ) );
    }

}
