// This file has been generated by Py++.

#include "boost/python.hpp"
#include "includes.h"
#include "iostream"
#include "cstdio"
#include "Alignatum.pypp.hpp"

namespace bp = boost::python;

void register_Alignatum_class(){

    { //::alignlib::Alignatum
        typedef bp::class_< alignlib::Alignatum, bp::bases< alignlib::AlignlibBase >, boost::noncopyable > Alignatum_exposer_t;
        Alignatum_exposer_t Alignatum_exposer = Alignatum_exposer_t( "Alignatum", bp::no_init );
        bp::scope Alignatum_scope( Alignatum_exposer );
        { //::alignlib::Alignatum::addGaps
        
            typedef void ( ::alignlib::Alignatum::*addGaps_function_type )( int,int ) ;
            
            Alignatum_exposer.def( 
                "addGaps"
                , addGaps_function_type( &::alignlib::Alignatum::addGaps )
                , ( bp::arg("front"), bp::arg("back") ) );
        
        }
        { //::alignlib::Alignatum::fillAlignment
        
            typedef void ( ::alignlib::Alignatum::*fillAlignment_function_type )( ::alignlib::HAlignment &,bool const ) const;
            
            Alignatum_exposer.def( 
                "fillAlignment"
                , fillAlignment_function_type( &::alignlib::Alignatum::fillAlignment )
                , ( bp::arg("dest"), bp::arg("invert")=(bool const)(false) ) );
        
        }
        { //::alignlib::Alignatum::getAlignedLength
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getAlignedLength_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getAlignedLength"
                , getAlignedLength_function_type( &::alignlib::Alignatum::getAlignedLength ) );
        
        }
        { //::alignlib::Alignatum::getClone
        
            typedef ::alignlib::HAlignatum ( ::alignlib::Alignatum::*getClone_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::Alignatum::getClone ) );
        
        }
        { //::alignlib::Alignatum::getFrom
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getFrom_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getFrom"
                , getFrom_function_type( &::alignlib::Alignatum::getFrom ) );
        
        }
        { //::alignlib::Alignatum::getFullLength
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getFullLength_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getFullLength"
                , getFullLength_function_type( &::alignlib::Alignatum::getFullLength ) );
        
        }
        { //::alignlib::Alignatum::getNew
        
            typedef ::alignlib::HAlignatum ( ::alignlib::Alignatum::*getNew_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getNew"
                , getNew_function_type( &::alignlib::Alignatum::getNew ) );
        
        }
        { //::alignlib::Alignatum::getResidueNumber
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getResidueNumber_function_type )( ::alignlib::Position const,::alignlib::SearchType const ) const;
            
            Alignatum_exposer.def( 
                "getResidueNumber"
                , getResidueNumber_function_type( &::alignlib::Alignatum::getResidueNumber )
                , ( bp::arg("pos"), bp::arg("search")=::alignlib::NO_SEARCH ) );
        
        }
        { //::alignlib::Alignatum::getString
        
            typedef ::std::string const & ( ::alignlib::Alignatum::*getString_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getString"
                , getString_function_type( &::alignlib::Alignatum::getString )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::alignlib::Alignatum::getTo
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getTo_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getTo"
                , getTo_function_type( &::alignlib::Alignatum::getTo ) );
        
        }
        { //::alignlib::Alignatum::insertGaps
        
            typedef void ( ::alignlib::Alignatum::*insertGaps_function_type )( int,::alignlib::Position ) ;
            
            Alignatum_exposer.def( 
                "insertGaps"
                , insertGaps_function_type( &::alignlib::Alignatum::insertGaps )
                , ( bp::arg("position"), bp::arg("count")=(int)(1) ) );
        
        }
        { //::alignlib::Alignatum::isConsistent
        
            typedef bool ( ::alignlib::Alignatum::*isConsistent_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "isConsistent"
                , isConsistent_function_type( &::alignlib::Alignatum::isConsistent ) );
        
        }
        { //::alignlib::Alignatum::mapOnAlignment
        
            typedef void ( ::alignlib::Alignatum::*mapOnAlignment_function_type )( ::alignlib::HAlignment const &,::alignlib::Position const,bool const ) ;
            
            Alignatum_exposer.def( 
                "mapOnAlignment"
                , mapOnAlignment_function_type( &::alignlib::Alignatum::mapOnAlignment )
                , ( bp::arg("map_old2new"), bp::arg("new_length")=(int const)(0), bp::arg("unaligned_chars")=(bool const)(false) ) );
        
        }
        { //::alignlib::Alignatum::read
        
            typedef void ( ::alignlib::Alignatum::*read_function_type )( ::std::istream & ) ;
            
            Alignatum_exposer.def( 
                "read"
                , read_function_type( &::alignlib::Alignatum::read )
                , ( bp::arg("input") ) );
        
        }
        { //::alignlib::Alignatum::removeColumns
        
            typedef void ( ::alignlib::Alignatum::*removeColumns_function_type )( int,::alignlib::Position ) ;
            
            Alignatum_exposer.def( 
                "removeColumns"
                , removeColumns_function_type( &::alignlib::Alignatum::removeColumns )
                , ( bp::arg("position"), bp::arg("count")=(int)(1) ) );
        
        }
        { //::alignlib::Alignatum::removeEndGaps
        
            typedef void ( ::alignlib::Alignatum::*removeEndGaps_function_type )(  ) ;
            
            Alignatum_exposer.def( 
                "removeEndGaps"
                , removeEndGaps_function_type( &::alignlib::Alignatum::removeEndGaps ) );
        
        }
        { //::alignlib::Alignatum::write
        
            typedef void ( ::alignlib::Alignatum::*write_function_type )( ::std::ostream & ) const;
            
            Alignatum_exposer.def( 
                "write"
                , write_function_type( &::alignlib::Alignatum::write )
                , ( bp::arg("output") ) );
        
        }
        Alignatum_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Alignatum > >();
        bp::implicitly_convertible< boost::shared_ptr< alignlib::Alignatum >, boost::shared_ptr< alignlib::AlignlibBase > >();
    }

}
