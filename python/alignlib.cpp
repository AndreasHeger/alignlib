// This file has been generated by Py++.

#include "boost/python.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "includes.h"

#include "iostream"

#include "cstdio"

namespace bp = boost::python;

struct AlignmentFormat_wrapper : alignlib::AlignmentFormat, bp::wrapper< alignlib::AlignmentFormat > {

    AlignmentFormat_wrapper( )
    : alignlib::AlignmentFormat( )
      , bp::wrapper< alignlib::AlignmentFormat >(){
        // null constructor
    
    }

    AlignmentFormat_wrapper(::alignlib::HAlignment const & src )
    : alignlib::AlignmentFormat( src )
      , bp::wrapper< alignlib::AlignmentFormat >(){
        // constructor
    
    }

    AlignmentFormat_wrapper(::std::istream & src )
    : alignlib::AlignmentFormat( boost::ref(src) )
      , bp::wrapper< alignlib::AlignmentFormat >(){
        // constructor
    
    }

    AlignmentFormat_wrapper(::std::string const & src )
    : alignlib::AlignmentFormat( src )
      , bp::wrapper< alignlib::AlignmentFormat >(){
        // constructor
    
    }

    AlignmentFormat_wrapper(::alignlib::AlignmentFormat const & arg0 )
    : alignlib::AlignmentFormat( boost::ref(arg0) )
      , bp::wrapper< alignlib::AlignmentFormat >(){
        // copy constructor
    
    }

    virtual void copy( ::alignlib::HAlignment & dest ) const  {
        if( bp::override func_copy = this->get_override( "copy" ) )
            func_copy( dest );
        else
            this->alignlib::AlignmentFormat::copy( dest );
    }
    
    
    void default_copy( ::alignlib::HAlignment & dest ) const  {
        alignlib::AlignmentFormat::copy( dest );
    }

    virtual void fill( ::alignlib::HAlignment const & src ) {
        if( bp::override func_fill = this->get_override( "fill" ) )
            func_fill( src );
        else
            this->alignlib::AlignmentFormat::fill( src );
    }
    
    
    void default_fill( ::alignlib::HAlignment const & src ) {
        alignlib::AlignmentFormat::fill( src );
    }

    virtual void load( ::std::istream & arg0 ) {
        if( bp::override func_load = this->get_override( "load" ) )
            func_load( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormat::load( boost::ref(arg0) );
    }
    
    
    void default_load( ::std::istream & arg0 ) {
        alignlib::AlignmentFormat::load( boost::ref(arg0) );
    }

    virtual void save( ::std::ostream & arg0 ) const  {
        if( bp::override func_save = this->get_override( "save" ) )
            func_save( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormat::save( boost::ref(arg0) );
    }
    
    
    void default_save( ::std::ostream & arg0 ) const  {
        alignlib::AlignmentFormat::save( boost::ref(arg0) );
    }

};

struct AlignmentFormatBlocks_wrapper : alignlib::AlignmentFormatBlocks, bp::wrapper< alignlib::AlignmentFormatBlocks > {

    AlignmentFormatBlocks_wrapper( )
    : alignlib::AlignmentFormatBlocks( )
      , bp::wrapper< alignlib::AlignmentFormatBlocks >(){
        // null constructor
    
    }

    AlignmentFormatBlocks_wrapper(::alignlib::HAlignment const & src )
    : alignlib::AlignmentFormatBlocks( src )
      , bp::wrapper< alignlib::AlignmentFormatBlocks >(){
        // constructor
    
    }

    AlignmentFormatBlocks_wrapper(::std::istream & src )
    : alignlib::AlignmentFormatBlocks( boost::ref(src) )
      , bp::wrapper< alignlib::AlignmentFormatBlocks >(){
        // constructor
    
    }

    AlignmentFormatBlocks_wrapper(::std::string const & src )
    : alignlib::AlignmentFormatBlocks( src )
      , bp::wrapper< alignlib::AlignmentFormatBlocks >(){
        // constructor
    
    }

    AlignmentFormatBlocks_wrapper(::alignlib::AlignmentFormatBlocks const & arg0 )
    : alignlib::AlignmentFormatBlocks( boost::ref(arg0) )
      , bp::wrapper< alignlib::AlignmentFormatBlocks >(){
        // copy constructor
    
    }

    virtual void copy( ::alignlib::HAlignment & dest ) const  {
        if( bp::override func_copy = this->get_override( "copy" ) )
            func_copy( dest );
        else
            this->alignlib::AlignmentFormatBlocks::copy( dest );
    }
    
    
    void default_copy( ::alignlib::HAlignment & dest ) const  {
        alignlib::AlignmentFormatBlocks::copy( dest );
    }

    virtual void fill( ::alignlib::HAlignment const & src ) {
        if( bp::override func_fill = this->get_override( "fill" ) )
            func_fill( src );
        else
            this->alignlib::AlignmentFormatBlocks::fill( src );
    }
    
    
    void default_fill( ::alignlib::HAlignment const & src ) {
        alignlib::AlignmentFormatBlocks::fill( src );
    }

    virtual void load( ::std::istream & arg0 ) {
        if( bp::override func_load = this->get_override( "load" ) )
            func_load( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormatBlocks::load( boost::ref(arg0) );
    }
    
    
    void default_load( ::std::istream & arg0 ) {
        alignlib::AlignmentFormatBlocks::load( boost::ref(arg0) );
    }

    virtual void save( ::std::ostream & arg0 ) const  {
        if( bp::override func_save = this->get_override( "save" ) )
            func_save( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormatBlocks::save( boost::ref(arg0) );
    }
    
    
    void default_save( ::std::ostream & arg0 ) const  {
        alignlib::AlignmentFormatBlocks::save( boost::ref(arg0) );
    }

};

struct AlignmentFormatDiagonals_wrapper : alignlib::AlignmentFormatDiagonals, bp::wrapper< alignlib::AlignmentFormatDiagonals > {

    AlignmentFormatDiagonals_wrapper( )
    : alignlib::AlignmentFormatDiagonals( )
      , bp::wrapper< alignlib::AlignmentFormatDiagonals >(){
        // null constructor
    
    }

    AlignmentFormatDiagonals_wrapper(::alignlib::HAlignment const & src )
    : alignlib::AlignmentFormatDiagonals( src )
      , bp::wrapper< alignlib::AlignmentFormatDiagonals >(){
        // constructor
    
    }

    AlignmentFormatDiagonals_wrapper(::std::istream & src )
    : alignlib::AlignmentFormatDiagonals( boost::ref(src) )
      , bp::wrapper< alignlib::AlignmentFormatDiagonals >(){
        // constructor
    
    }

    AlignmentFormatDiagonals_wrapper(::std::string const & src )
    : alignlib::AlignmentFormatDiagonals( src )
      , bp::wrapper< alignlib::AlignmentFormatDiagonals >(){
        // constructor
    
    }

    AlignmentFormatDiagonals_wrapper(::alignlib::AlignmentFormatDiagonals const & arg0 )
    : alignlib::AlignmentFormatDiagonals( boost::ref(arg0) )
      , bp::wrapper< alignlib::AlignmentFormatDiagonals >(){
        // copy constructor
    
    }

    virtual void copy( ::alignlib::HAlignment & dest, bool const reverse ) const  {
        if( bp::override func_copy = this->get_override( "copy" ) )
            func_copy( dest, reverse );
        else
            this->alignlib::AlignmentFormatDiagonals::copy( dest, reverse );
    }
    
    
    void default_copy( ::alignlib::HAlignment & dest, bool const reverse ) const  {
        alignlib::AlignmentFormatDiagonals::copy( dest, reverse );
    }

    virtual void copy( ::alignlib::HAlignment & dest ) const  {
        if( bp::override func_copy = this->get_override( "copy" ) )
            func_copy( dest );
        else
            this->alignlib::AlignmentFormatDiagonals::copy( dest );
    }
    
    
    void default_copy( ::alignlib::HAlignment & dest ) const  {
        alignlib::AlignmentFormatDiagonals::copy( dest );
    }

    virtual void fill( ::alignlib::HAlignment const & src, bool const reverse, ::alignlib::Position const row_from=-1, ::alignlib::Position const row_to=-1, ::alignlib::Position const col_from=-1, ::alignlib::Position const col_to=-1, ::alignlib::Diagonal const diagonal_from=99999999, ::alignlib::Diagonal const diagonal_to=-99999999 ) {
        if( bp::override func_fill = this->get_override( "fill" ) )
            func_fill( src, reverse, row_from, row_to, col_from, col_to, diagonal_from, diagonal_to );
        else
            this->alignlib::AlignmentFormatDiagonals::fill( src, reverse, row_from, row_to, col_from, col_to, diagonal_from, diagonal_to );
    }
    
    
    void default_fill( ::alignlib::HAlignment const & src, bool const reverse, ::alignlib::Position const row_from=-1, ::alignlib::Position const row_to=-1, ::alignlib::Position const col_from=-1, ::alignlib::Position const col_to=-1, ::alignlib::Diagonal const diagonal_from=99999999, ::alignlib::Diagonal const diagonal_to=-99999999 ) {
        alignlib::AlignmentFormatDiagonals::fill( src, reverse, row_from, row_to, col_from, col_to, diagonal_from, diagonal_to );
    }

    virtual void fill( ::alignlib::HAlignment const & src ) {
        if( bp::override func_fill = this->get_override( "fill" ) )
            func_fill( src );
        else
            this->alignlib::AlignmentFormatDiagonals::fill( src );
    }
    
    
    void default_fill( ::alignlib::HAlignment const & src ) {
        alignlib::AlignmentFormatDiagonals::fill( src );
    }

    virtual void load( ::std::istream & arg0 ) {
        if( bp::override func_load = this->get_override( "load" ) )
            func_load( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormatDiagonals::load( boost::ref(arg0) );
    }
    
    
    void default_load( ::std::istream & arg0 ) {
        alignlib::AlignmentFormatDiagonals::load( boost::ref(arg0) );
    }

    virtual void save( ::std::ostream & arg0 ) const  {
        if( bp::override func_save = this->get_override( "save" ) )
            func_save( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormatDiagonals::save( boost::ref(arg0) );
    }
    
    
    void default_save( ::std::ostream & arg0 ) const  {
        alignlib::AlignmentFormatDiagonals::save( boost::ref(arg0) );
    }

};

struct AlignmentFormatEmissions_wrapper : alignlib::AlignmentFormatEmissions, bp::wrapper< alignlib::AlignmentFormatEmissions > {

    AlignmentFormatEmissions_wrapper( )
    : alignlib::AlignmentFormatEmissions( )
      , bp::wrapper< alignlib::AlignmentFormatEmissions >(){
        // null constructor
    
    }

    AlignmentFormatEmissions_wrapper(::alignlib::HAlignment const & src )
    : alignlib::AlignmentFormatEmissions( src )
      , bp::wrapper< alignlib::AlignmentFormatEmissions >(){
        // constructor
    
    }

    AlignmentFormatEmissions_wrapper(::std::istream & src )
    : alignlib::AlignmentFormatEmissions( boost::ref(src) )
      , bp::wrapper< alignlib::AlignmentFormatEmissions >(){
        // constructor
    
    }

    AlignmentFormatEmissions_wrapper(::std::string const & src )
    : alignlib::AlignmentFormatEmissions( src )
      , bp::wrapper< alignlib::AlignmentFormatEmissions >(){
        // constructor
    
    }

    AlignmentFormatEmissions_wrapper(::alignlib::AlignmentFormatEmissions const & arg0 )
    : alignlib::AlignmentFormatEmissions( boost::ref(arg0) )
      , bp::wrapper< alignlib::AlignmentFormatEmissions >(){
        // copy constructor
    
    }

    AlignmentFormatEmissions_wrapper(::alignlib::Position const row_from, ::std::string const & row, ::alignlib::Position const col_from, ::std::string const & col )
    : alignlib::AlignmentFormatEmissions( row_from, row, col_from, col )
      , bp::wrapper< alignlib::AlignmentFormatEmissions >(){
        // constructor
    
    }

    virtual void copy( ::alignlib::HAlignment & dest ) const  {
        if( bp::override func_copy = this->get_override( "copy" ) )
            func_copy( dest );
        else
            this->alignlib::AlignmentFormatEmissions::copy( dest );
    }
    
    
    void default_copy( ::alignlib::HAlignment & dest ) const  {
        alignlib::AlignmentFormatEmissions::copy( dest );
    }

    virtual void fill( ::alignlib::HAlignment const & src ) {
        if( bp::override func_fill = this->get_override( "fill" ) )
            func_fill( src );
        else
            this->alignlib::AlignmentFormatEmissions::fill( src );
    }
    
    
    void default_fill( ::alignlib::HAlignment const & src ) {
        alignlib::AlignmentFormatEmissions::fill( src );
    }

    virtual ::alignlib::Position getNumEmissions( ::std::string const & src ) {
        if( bp::override func_getNumEmissions = this->get_override( "getNumEmissions" ) )
            return func_getNumEmissions( src );
        else
            return this->alignlib::AlignmentFormatEmissions::getNumEmissions( src );
    }
    
    
    ::alignlib::Position default_getNumEmissions( ::std::string const & src ) {
        return alignlib::AlignmentFormatEmissions::getNumEmissions( src );
    }

    virtual void load( ::std::istream & arg0 ) {
        if( bp::override func_load = this->get_override( "load" ) )
            func_load( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormatEmissions::load( boost::ref(arg0) );
    }
    
    
    void default_load( ::std::istream & arg0 ) {
        alignlib::AlignmentFormatEmissions::load( boost::ref(arg0) );
    }

    virtual void save( ::std::ostream & arg0 ) const  {
        if( bp::override func_save = this->get_override( "save" ) )
            func_save( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormatEmissions::save( boost::ref(arg0) );
    }
    
    
    void default_save( ::std::ostream & arg0 ) const  {
        alignlib::AlignmentFormatEmissions::save( boost::ref(arg0) );
    }

};

struct AlignmentFormatExplicit_wrapper : alignlib::AlignmentFormatExplicit, bp::wrapper< alignlib::AlignmentFormatExplicit > {

    AlignmentFormatExplicit_wrapper( )
    : alignlib::AlignmentFormatExplicit( )
      , bp::wrapper< alignlib::AlignmentFormatExplicit >(){
        // null constructor
    
    }

    AlignmentFormatExplicit_wrapper(::alignlib::HAlignment const & src, ::alignlib::HAlignandum const & row, ::alignlib::HAlignandum const & col )
    : alignlib::AlignmentFormatExplicit( src, row, col )
      , bp::wrapper< alignlib::AlignmentFormatExplicit >(){
        // constructor
    
    }

    AlignmentFormatExplicit_wrapper(::std::istream & src )
    : alignlib::AlignmentFormatExplicit( boost::ref(src) )
      , bp::wrapper< alignlib::AlignmentFormatExplicit >(){
        // constructor
    
    }

    AlignmentFormatExplicit_wrapper(::std::string const & src )
    : alignlib::AlignmentFormatExplicit( src )
      , bp::wrapper< alignlib::AlignmentFormatExplicit >(){
        // constructor
    
    }

    AlignmentFormatExplicit_wrapper(::alignlib::Position const row_from, ::std::string const & row, ::alignlib::Position const col_from, ::std::string const & col )
    : alignlib::AlignmentFormatExplicit( row_from, row, col_from, col )
      , bp::wrapper< alignlib::AlignmentFormatExplicit >(){
        // constructor
    
    }

    AlignmentFormatExplicit_wrapper(::alignlib::AlignmentFormatExplicit const & arg0 )
    : alignlib::AlignmentFormatExplicit( boost::ref(arg0) )
      , bp::wrapper< alignlib::AlignmentFormatExplicit >(){
        // copy constructor
    
    }

    virtual void copy( ::alignlib::HAlignment & dest ) const  {
        if( bp::override func_copy = this->get_override( "copy" ) )
            func_copy( dest );
        else
            this->alignlib::AlignmentFormatExplicit::copy( dest );
    }
    
    
    void default_copy( ::alignlib::HAlignment & dest ) const  {
        alignlib::AlignmentFormatExplicit::copy( dest );
    }

    virtual void fill( ::alignlib::HAlignment const & src, ::alignlib::HAlignandum const & row, ::alignlib::HAlignandum const & col ) {
        if( bp::override func_fill = this->get_override( "fill" ) )
            func_fill( src, row, col );
        else
            this->alignlib::AlignmentFormatExplicit::fill( src, row, col );
    }
    
    
    void default_fill( ::alignlib::HAlignment const & src, ::alignlib::HAlignandum const & row, ::alignlib::HAlignandum const & col ) {
        alignlib::AlignmentFormatExplicit::fill( src, row, col );
    }

    virtual void load( ::std::istream & arg0 ) {
        if( bp::override func_load = this->get_override( "load" ) )
            func_load( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormatExplicit::load( boost::ref(arg0) );
    }
    
    
    void default_load( ::std::istream & arg0 ) {
        alignlib::AlignmentFormatExplicit::load( boost::ref(arg0) );
    }

    virtual void save( ::std::ostream & arg0 ) const  {
        if( bp::override func_save = this->get_override( "save" ) )
            func_save( boost::ref(arg0) );
        else
            this->alignlib::AlignmentFormatExplicit::save( boost::ref(arg0) );
    }
    
    
    void default_save( ::std::ostream & arg0 ) const  {
        alignlib::AlignmentFormatExplicit::save( boost::ref(arg0) );
    }

};

class std_obuf: public std::streambuf 
        {
      public:
        std_obuf(std::FILE* file): m_file(file) {}
      protected:
        std::streambuf::int_type overflow(std::streambuf::int_type c) 
        {
          return std::fputc(c, m_file) ==EOF? std::streambuf::traits_type::eof(): c;
        }
      private:
        FILE* m_file;
      };

    class std_ibuf: public std::streambuf 
        {
      public:
          std_ibuf(std::FILE* file): m_file(file) {}
      protected:
          std::streambuf::int_type underflow() { 
           int c = std::getc(m_file);
           if (c != EOF) 
               std::ungetc(c, m_file);
            return c;
           }

          std::streambuf::int_type uflow() {
           return std::getc(m_file);
          }

          std::streambuf::int_type pbackfail(int c = EOF) {
            return c != EOF ? std::ungetc(c, m_file) : EOF;
          }
    private:
          FILE* m_file;      
          
      };

template<class T>
      void wrapper_for_save(const T & a, PyObject* fp) 
      {
        if (!PyFile_Check(fp)) 
        {
          throw boost::python::error_already_set();
        }
        std::FILE* f = PyFile_AsFile(fp);
        std_obuf buf(f);
        std::ostream os(&buf);
        a.save( os );
      }

alignlib::HAlignandum wrapper_for_load_Alignandum( PyObject * fp )
      {
          if (!PyFile_Check(fp))
          {
              throw boost::python::error_already_set();
          }
         std::FILE * f = PyFile_AsFile(fp);   
         std_ibuf buf(f);
         std::istream is(&buf);
         if (is.peek() == EOF)
             return alignlib::HAlignandum();
         else
             return alignlib::HAlignandum (alignlib::loadAlignandum( is ));
      }

alignlib::HEncoder wrapper_for_load_Encoder( PyObject * fp )
      {
          if (!PyFile_Check(fp))
          {
              throw boost::python::error_already_set();
          }
         std::FILE * f = PyFile_AsFile(fp);   
         std_ibuf buf(f);
         std::istream is(&buf);
         if (is.peek() == EOF)
             return alignlib::HEncoder();
         else
             return alignlib::HEncoder (alignlib::loadEncoder( is ));
      }

BOOST_PYTHON_MODULE(alignlib){
    bp::class_< std::vector<unsigned int,std::allocator<unsigned int> > >("vector_less_unsigned_int_comma_std_scope_allocator_less_unsigned_int_grate___grate_")    
        .def( bp::vector_indexing_suite< ::std::vector<unsigned int,std::allocator<unsigned int> >, true >() );

    bp::class_< std::vector<unsigned char,std::allocator<unsigned char> > >("vector_less_unsigned_char_comma_std_scope_allocator_less_unsigned_char_grate___grate_")    
        .def( bp::vector_indexing_suite< ::std::vector<unsigned char,std::allocator<unsigned char> >, true >() );

    { //::std::vector<std::string, std::allocator<std::string> >
        typedef bp::class_< std::vector<std::string, std::allocator<std::string> > > Labels_exposer_t;
        Labels_exposer_t Labels_exposer = Labels_exposer_t( "Labels" );
        bp::scope Labels_scope( Labels_exposer );
        Labels_exposer.def( bp::vector_indexing_suite< ::std::vector<std::string, std::allocator<std::string> >, true >() );
    }

    { //::std::vector<int, std::allocator<int> >
        typedef bp::class_< std::vector<int, std::allocator<int> > > PositionVector_exposer_t;
        PositionVector_exposer_t PositionVector_exposer = PositionVector_exposer_t( "PositionVector" );
        bp::scope PositionVector_scope( PositionVector_exposer );
        PositionVector_exposer.def( bp::vector_indexing_suite< ::std::vector<int, std::allocator<int> >, true >() );
    }

    { //::std::vector<double, std::allocator<double> >
        typedef bp::class_< std::vector<double, std::allocator<double> > > vector_less_double_comma__std_scope_allocator_less_double_grate___grate__exposer_t;
        vector_less_double_comma__std_scope_allocator_less_double_grate___grate__exposer_t vector_less_double_comma__std_scope_allocator_less_double_grate___grate__exposer = vector_less_double_comma__std_scope_allocator_less_double_grate___grate__exposer_t( "vector_less_double_comma__std_scope_allocator_less_double_grate___grate_" );
        bp::scope vector_less_double_comma__std_scope_allocator_less_double_grate___grate__scope( vector_less_double_comma__std_scope_allocator_less_double_grate___grate__exposer );
        vector_less_double_comma__std_scope_allocator_less_double_grate___grate__exposer.def( bp::vector_indexing_suite< ::std::vector<double, std::allocator<double> >, true >() );
    }

    bp::enum_< alignlib::AlignmentType>("AlignmentType")
        .value("ALIGNMENT_LOCAL", alignlib::ALIGNMENT_LOCAL)
        .value("ALIGNMENT_WRAP", alignlib::ALIGNMENT_WRAP)
        .value("ALIGNMENT_GLOBAL", alignlib::ALIGNMENT_GLOBAL)
        .export_values()
        ;

    bp::enum_< alignlib::AlphabetType>("AlphabetType")
        .value("User", alignlib::User)
        .value("Protein20", alignlib::Protein20)
        .value("Protein23", alignlib::Protein23)
        .value("DNA4", alignlib::DNA4)
        .export_values()
        ;

    bp::enum_< alignlib::CombinationMode>("CombinationMode")
        .value("RR", alignlib::RR)
        .value("RC", alignlib::RC)
        .value("CR", alignlib::CR)
        .value("CC", alignlib::CC)
        .export_values()
        ;

    bp::enum_< alignlib::LinkageType>("LinkageType")
        .value("SINGLE_LINKAGE", alignlib::SINGLE_LINKAGE)
        .value("COMPLETE_LINKAGE", alignlib::COMPLETE_LINKAGE)
        .value("AVERAGE_LINKAGE", alignlib::AVERAGE_LINKAGE)
        .value("UPGMA", alignlib::UPGMA)
        .value("WPGMA", alignlib::WPGMA)
        .value("UPGMC", alignlib::UPGMC)
        .value("WPGMC", alignlib::WPGMC)
        .export_values()
        ;

    bp::enum_< alignlib::SearchType>("SearchType")
        .value("NO_SEARCH", alignlib::NO_SEARCH)
        .value("LEFT", alignlib::LEFT)
        .value("RIGHT", alignlib::RIGHT)
        .export_values()
        ;

    { //::alignlib::Alignandum
        typedef bp::class_< alignlib::Alignandum, boost::noncopyable > Alignandum_exposer_t;
        Alignandum_exposer_t Alignandum_exposer = Alignandum_exposer_t( "Alignandum", bp::no_init );
        bp::scope Alignandum_scope( Alignandum_exposer );
        { //::alignlib::Alignandum::asChar
        
            typedef char ( ::alignlib::Alignandum::*asChar_function_type )( ::alignlib::Position ) const;
            
            Alignandum_exposer.def( 
                "asChar"
                , asChar_function_type( &::alignlib::Alignandum::asChar )
                , ( bp::arg("pos") ) );
        
        }
        { //::alignlib::Alignandum::asResidue
        
            typedef ::alignlib::Residue ( ::alignlib::Alignandum::*asResidue_function_type )( ::alignlib::Position ) const;
            
            Alignandum_exposer.def( 
                "asResidue"
                , asResidue_function_type( &::alignlib::Alignandum::asResidue )
                , ( bp::arg("pos") ) );
        
        }
        { //::alignlib::Alignandum::asString
        
            typedef ::std::string ( ::alignlib::Alignandum::*asString_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "asString"
                , asString_function_type( &::alignlib::Alignandum::asString ) );
        
        }
        { //::alignlib::Alignandum::getClone
        
            typedef ::alignlib::HAlignandum ( ::alignlib::Alignandum::*getClone_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::Alignandum::getClone ) );
        
        }
        { //::alignlib::Alignandum::getEncoder
        
            typedef ::alignlib::HEncoder const & ( ::alignlib::Alignandum::*getEncoder_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getEncoder"
                , getEncoder_function_type( &::alignlib::Alignandum::getEncoder )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::alignlib::Alignandum::getFrom
        
            typedef ::alignlib::Position ( ::alignlib::Alignandum::*getFrom_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getFrom"
                , getFrom_function_type( &::alignlib::Alignandum::getFrom ) );
        
        }
        { //::alignlib::Alignandum::getFullLength
        
            typedef ::alignlib::Position ( ::alignlib::Alignandum::*getFullLength_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getFullLength"
                , getFullLength_function_type( &::alignlib::Alignandum::getFullLength ) );
        
        }
        { //::alignlib::Alignandum::getLength
        
            typedef ::alignlib::Position ( ::alignlib::Alignandum::*getLength_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getLength"
                , getLength_function_type( &::alignlib::Alignandum::getLength ) );
        
        }
        { //::alignlib::Alignandum::getTo
        
            typedef ::alignlib::Position ( ::alignlib::Alignandum::*getTo_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "getTo"
                , getTo_function_type( &::alignlib::Alignandum::getTo ) );
        
        }
        { //::alignlib::Alignandum::isMasked
        
            typedef bool ( ::alignlib::Alignandum::*isMasked_function_type )( ::alignlib::Position const & ) const;
            
            Alignandum_exposer.def( 
                "isMasked"
                , isMasked_function_type( &::alignlib::Alignandum::isMasked )
                , ( bp::arg("pos") ) );
        
        }
        { //::alignlib::Alignandum::isPrepared
        
            typedef bool ( ::alignlib::Alignandum::*isPrepared_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "isPrepared"
                , isPrepared_function_type( &::alignlib::Alignandum::isPrepared ) );
        
        }
        { //::alignlib::Alignandum::mask
        
            typedef void ( ::alignlib::Alignandum::*mask_function_type )( ::alignlib::Position const &,::alignlib::Position const & ) ;
            
            Alignandum_exposer.def( 
                "mask"
                , mask_function_type( &::alignlib::Alignandum::mask )
                , ( bp::arg("from"), bp::arg("to")=-1 ) );
        
        }
        { //::alignlib::Alignandum::prepare
        
            typedef void ( ::alignlib::Alignandum::*prepare_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "prepare"
                , prepare_function_type( &::alignlib::Alignandum::prepare ) );
        
        }
        { //::alignlib::Alignandum::release
        
            typedef void ( ::alignlib::Alignandum::*release_function_type )(  ) const;
            
            Alignandum_exposer.def( 
                "release"
                , release_function_type( &::alignlib::Alignandum::release ) );
        
        }
        { //::alignlib::Alignandum::shuffle
        
            typedef void ( ::alignlib::Alignandum::*shuffle_function_type )( unsigned int,::alignlib::Position ) ;
            
            Alignandum_exposer.def( 
                "shuffle"
                , shuffle_function_type( &::alignlib::Alignandum::shuffle )
                , ( bp::arg("num_iterations")=(unsigned int)(1), bp::arg("window_size")=(int)(0) ) );
        
        }
        { //::alignlib::Alignandum::swap
        
            typedef void ( ::alignlib::Alignandum::*swap_function_type )( ::alignlib::Position const &,::alignlib::Position const & ) ;
            
            Alignandum_exposer.def( 
                "swap"
                , swap_function_type( &::alignlib::Alignandum::swap )
                , ( bp::arg("x"), bp::arg("y") ) );
        
        }
        { //::alignlib::Alignandum::useSegment
        
            typedef void ( ::alignlib::Alignandum::*useSegment_function_type )( ::alignlib::Position,::alignlib::Position ) ;
            
            Alignandum_exposer.def( 
                "useSegment"
                , useSegment_function_type( &::alignlib::Alignandum::useSegment )
                , ( bp::arg("from")=(int)(-1), bp::arg("to")=(int)(-1) ) );
        
        }
        { //::alignlib::Alignandum::write
        
            typedef void ( ::alignlib::Alignandum::*write_function_type )( ::std::ostream & ) const;
            
            Alignandum_exposer.def( 
                "write"
                , write_function_type( &::alignlib::Alignandum::write )
                , ( bp::arg("output") ) );
        
        }
        Alignandum_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Alignandum > >();
        Alignandum_exposer.def( "save", wrapper_for_save<alignlib::Alignandum> );
    }

    { //::alignlib::Alignator
        typedef bp::class_< alignlib::Alignator, boost::noncopyable > Alignator_exposer_t;
        Alignator_exposer_t Alignator_exposer = Alignator_exposer_t( "Alignator", bp::no_init );
        bp::scope Alignator_scope( Alignator_exposer );
        { //::alignlib::Alignator::align
        
            typedef void ( ::alignlib::Alignator::*align_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignandum const &,::alignlib::HAlignandum const & ) ;
            
            Alignator_exposer.def( 
                "align"
                , align_function_type( &::alignlib::Alignator::align )
                , ( bp::arg("dest"), bp::arg("row"), bp::arg("col") ) );
        
        }
        { //::alignlib::Alignator::getClone
        
            typedef ::alignlib::HAlignator ( ::alignlib::Alignator::*getClone_function_type )(  ) const;
            
            Alignator_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::Alignator::getClone ) );
        
        }
        { //::alignlib::Alignator::setIterator2D
        
            typedef void ( ::alignlib::Alignator::*setIterator2D_function_type )( ::alignlib::HIterator2D const & ) ;
            
            Alignator_exposer.def( 
                "setIterator2D"
                , setIterator2D_function_type( &::alignlib::Alignator::setIterator2D )
                , ( bp::arg("iterator") ) );
        
        }
        { //::alignlib::Alignator::setScorer
        
            typedef void ( ::alignlib::Alignator::*setScorer_function_type )( ::alignlib::HScorer const & ) ;
            
            Alignator_exposer.def( 
                "setScorer"
                , setScorer_function_type( &::alignlib::Alignator::setScorer )
                , ( bp::arg("scorer") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Alignator > >();
    }

    { //::alignlib::Alignatum
        typedef bp::class_< alignlib::Alignatum, boost::noncopyable > Alignatum_exposer_t;
        Alignatum_exposer_t Alignatum_exposer = Alignatum_exposer_t( "Alignatum", bp::no_init );
        bp::scope Alignatum_scope( Alignatum_exposer );
        { //::alignlib::Alignatum::addGaps
        
            typedef void ( ::alignlib::Alignatum::*addGaps_function_type )( int,int ) ;
            
            Alignatum_exposer.def( 
                "addGaps"
                , addGaps_function_type( &::alignlib::Alignatum::addGaps )
                , ( bp::arg("front"), bp::arg("back") ) );
        
        }
        { //::alignlib::Alignatum::getAlignedLength
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getAlignedLength_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getAlignedLength"
                , getAlignedLength_function_type( &::alignlib::Alignatum::getAlignedLength ) );
        
        }
        { //::alignlib::Alignatum::getClone
        
            typedef ::alignlib::HAlignatum ( ::alignlib::Alignatum::*getClone_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::Alignatum::getClone ) );
        
        }
        { //::alignlib::Alignatum::getFrom
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getFrom_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getFrom"
                , getFrom_function_type( &::alignlib::Alignatum::getFrom ) );
        
        }
        { //::alignlib::Alignatum::getFullLength
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getFullLength_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getFullLength"
                , getFullLength_function_type( &::alignlib::Alignatum::getFullLength ) );
        
        }
        { //::alignlib::Alignatum::getNew
        
            typedef ::alignlib::HAlignatum ( ::alignlib::Alignatum::*getNew_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getNew"
                , getNew_function_type( &::alignlib::Alignatum::getNew ) );
        
        }
        { //::alignlib::Alignatum::getResidueNumber
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getResidueNumber_function_type )( ::alignlib::Position const,::alignlib::SearchType const ) const;
            
            Alignatum_exposer.def( 
                "getResidueNumber"
                , getResidueNumber_function_type( &::alignlib::Alignatum::getResidueNumber )
                , ( bp::arg("pos"), bp::arg("search")=::alignlib::NO_SEARCH ) );
        
        }
        { //::alignlib::Alignatum::getString
        
            typedef ::std::string const & ( ::alignlib::Alignatum::*getString_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getString"
                , getString_function_type( &::alignlib::Alignatum::getString )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::alignlib::Alignatum::getTo
        
            typedef ::alignlib::Position ( ::alignlib::Alignatum::*getTo_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "getTo"
                , getTo_function_type( &::alignlib::Alignatum::getTo ) );
        
        }
        { //::alignlib::Alignatum::insertGaps
        
            typedef void ( ::alignlib::Alignatum::*insertGaps_function_type )( int,::alignlib::Position ) ;
            
            Alignatum_exposer.def( 
                "insertGaps"
                , insertGaps_function_type( &::alignlib::Alignatum::insertGaps )
                , ( bp::arg("position"), bp::arg("count")=(int)(1) ) );
        
        }
        { //::alignlib::Alignatum::isConsistent
        
            typedef bool ( ::alignlib::Alignatum::*isConsistent_function_type )(  ) const;
            
            Alignatum_exposer.def( 
                "isConsistent"
                , isConsistent_function_type( &::alignlib::Alignatum::isConsistent ) );
        
        }
        { //::alignlib::Alignatum::mapOnAlignment
        
            typedef void ( ::alignlib::Alignatum::*mapOnAlignment_function_type )( ::alignlib::HAlignment const &,::alignlib::Position const,bool const ) ;
            
            Alignatum_exposer.def( 
                "mapOnAlignment"
                , mapOnAlignment_function_type( &::alignlib::Alignatum::mapOnAlignment )
                , ( bp::arg("map_old2new"), bp::arg("new_length")=(int const)(0), bp::arg("unaligned_chars")=(bool const)(false) ) );
        
        }
        { //::alignlib::Alignatum::read
        
            typedef void ( ::alignlib::Alignatum::*read_function_type )( ::std::istream & ) ;
            
            Alignatum_exposer.def( 
                "read"
                , read_function_type( &::alignlib::Alignatum::read )
                , ( bp::arg("input") ) );
        
        }
        { //::alignlib::Alignatum::removeColumns
        
            typedef void ( ::alignlib::Alignatum::*removeColumns_function_type )( int,::alignlib::Position ) ;
            
            Alignatum_exposer.def( 
                "removeColumns"
                , removeColumns_function_type( &::alignlib::Alignatum::removeColumns )
                , ( bp::arg("position"), bp::arg("count")=(int)(1) ) );
        
        }
        { //::alignlib::Alignatum::removeEndGaps
        
            typedef void ( ::alignlib::Alignatum::*removeEndGaps_function_type )(  ) ;
            
            Alignatum_exposer.def( 
                "removeEndGaps"
                , removeEndGaps_function_type( &::alignlib::Alignatum::removeEndGaps ) );
        
        }
        { //::alignlib::Alignatum::write
        
            typedef void ( ::alignlib::Alignatum::*write_function_type )( ::std::ostream & ) const;
            
            Alignatum_exposer.def( 
                "write"
                , write_function_type( &::alignlib::Alignatum::write )
                , ( bp::arg("output") ) );
        
        }
        Alignatum_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Alignatum > >();
    }

    { //::alignlib::Alignment
        typedef bp::class_< alignlib::Alignment, boost::noncopyable > Alignment_exposer_t;
        Alignment_exposer_t Alignment_exposer = Alignment_exposer_t( "Alignment", bp::no_init );
        bp::scope Alignment_scope( Alignment_exposer );
        { //::alignlib::Alignment::addDiagonal
        
            typedef void ( ::alignlib::Alignment::*addDiagonal_function_type )( ::alignlib::Position,::alignlib::Position,::alignlib::Position ) ;
            
            Alignment_exposer.def( 
                "addDiagonal"
                , addDiagonal_function_type( &::alignlib::Alignment::addDiagonal )
                , ( bp::arg("row_from"), bp::arg("row_to"), bp::arg("col_offset")=(int)(0) ) );
        
        }
        { //::alignlib::Alignment::addPair
        
            typedef void ( ::alignlib::Alignment::*addPair_function_type )( ::alignlib::ResiduePair const & ) ;
            
            Alignment_exposer.def( 
                "addPair"
                , addPair_function_type( &::alignlib::Alignment::addPair )
                , ( bp::arg("pair") ) );
        
        }
        { //::alignlib::Alignment::addPair
        
            typedef void ( ::alignlib::Alignment::*addPair_function_type )( ::alignlib::Position,::alignlib::Position,::alignlib::Score ) ;
            
            Alignment_exposer.def( 
                "addPair"
                , addPair_function_type( &::alignlib::Alignment::addPair )
                , ( bp::arg("row"), bp::arg("col"), bp::arg("score")=0 ) );
        
        }
        { //::alignlib::Alignment::back
        
            typedef ::alignlib::ResiduePair ( ::alignlib::Alignment::*back_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "back"
                , back_function_type( &::alignlib::Alignment::back ) );
        
        }
        { //::alignlib::Alignment::begin
        
            typedef ::alignlib::AlignmentIterator ( ::alignlib::Alignment::*begin_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "begin"
                , begin_function_type( &::alignlib::Alignment::begin ) );
        
        }
        { //::alignlib::Alignment::clear
        
            typedef void ( ::alignlib::Alignment::*clear_function_type )(  ) ;
            
            Alignment_exposer.def( 
                "clear"
                , clear_function_type( &::alignlib::Alignment::clear ) );
        
        }
        { //::alignlib::Alignment::end
        
            typedef ::alignlib::AlignmentIterator ( ::alignlib::Alignment::*end_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "end"
                , end_function_type( &::alignlib::Alignment::end ) );
        
        }
        { //::alignlib::Alignment::front
        
            typedef ::alignlib::ResiduePair ( ::alignlib::Alignment::*front_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "front"
                , front_function_type( &::alignlib::Alignment::front ) );
        
        }
        { //::alignlib::Alignment::getClone
        
            typedef ::alignlib::HAlignment ( ::alignlib::Alignment::*getClone_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::Alignment::getClone ) );
        
        }
        { //::alignlib::Alignment::getColFrom
        
            typedef ::alignlib::Position ( ::alignlib::Alignment::*getColFrom_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getColFrom"
                , getColFrom_function_type( &::alignlib::Alignment::getColFrom ) );
        
        }
        { //::alignlib::Alignment::getColTo
        
            typedef ::alignlib::Position ( ::alignlib::Alignment::*getColTo_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getColTo"
                , getColTo_function_type( &::alignlib::Alignment::getColTo ) );
        
        }
        { //::alignlib::Alignment::getLength
        
            typedef ::alignlib::Position ( ::alignlib::Alignment::*getLength_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getLength"
                , getLength_function_type( &::alignlib::Alignment::getLength ) );
        
        }
        { //::alignlib::Alignment::getNew
        
            typedef ::alignlib::HAlignment ( ::alignlib::Alignment::*getNew_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getNew"
                , getNew_function_type( &::alignlib::Alignment::getNew ) );
        
        }
        { //::alignlib::Alignment::getNumAligned
        
            typedef ::alignlib::Position ( ::alignlib::Alignment::*getNumAligned_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getNumAligned"
                , getNumAligned_function_type( &::alignlib::Alignment::getNumAligned ) );
        
        }
        { //::alignlib::Alignment::getNumGaps
        
            typedef ::alignlib::Position ( ::alignlib::Alignment::*getNumGaps_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getNumGaps"
                , getNumGaps_function_type( &::alignlib::Alignment::getNumGaps ) );
        
        }
        { //::alignlib::Alignment::getPair
        
            typedef ::alignlib::ResiduePair ( ::alignlib::Alignment::*getPair_function_type )( ::alignlib::ResiduePair const & ) const;
            
            Alignment_exposer.def( 
                "getPair"
                , getPair_function_type( &::alignlib::Alignment::getPair )
                , ( bp::arg("p") ) );
        
        }
        { //::alignlib::Alignment::getRowFrom
        
            typedef ::alignlib::Position ( ::alignlib::Alignment::*getRowFrom_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getRowFrom"
                , getRowFrom_function_type( &::alignlib::Alignment::getRowFrom ) );
        
        }
        { //::alignlib::Alignment::getRowTo
        
            typedef ::alignlib::Position ( ::alignlib::Alignment::*getRowTo_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getRowTo"
                , getRowTo_function_type( &::alignlib::Alignment::getRowTo ) );
        
        }
        { //::alignlib::Alignment::getScore
        
            typedef ::alignlib::Score ( ::alignlib::Alignment::*getScore_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "getScore"
                , getScore_function_type( &::alignlib::Alignment::getScore ) );
        
        }
        { //::alignlib::Alignment::isEmpty
        
            typedef bool ( ::alignlib::Alignment::*isEmpty_function_type )(  ) const;
            
            Alignment_exposer.def( 
                "isEmpty"
                , isEmpty_function_type( &::alignlib::Alignment::isEmpty ) );
        
        }
        { //::alignlib::Alignment::mapColToRow
        
            typedef ::alignlib::Position ( ::alignlib::Alignment::*mapColToRow_function_type )( ::alignlib::Position,::alignlib::SearchType ) const;
            
            Alignment_exposer.def( 
                "mapColToRow"
                , mapColToRow_function_type( &::alignlib::Alignment::mapColToRow )
                , ( bp::arg("pos"), bp::arg("search")=::alignlib::NO_SEARCH ) );
        
        }
        { //::alignlib::Alignment::mapRowToCol
        
            typedef ::alignlib::Position ( ::alignlib::Alignment::*mapRowToCol_function_type )( ::alignlib::Position,::alignlib::SearchType ) const;
            
            Alignment_exposer.def( 
                "mapRowToCol"
                , mapRowToCol_function_type( &::alignlib::Alignment::mapRowToCol )
                , ( bp::arg("pos"), bp::arg("search")=::alignlib::NO_SEARCH ) );
        
        }
        { //::alignlib::Alignment::moveAlignment
        
            typedef void ( ::alignlib::Alignment::*moveAlignment_function_type )( ::alignlib::Position,::alignlib::Position ) ;
            
            Alignment_exposer.def( 
                "moveAlignment"
                , moveAlignment_function_type( &::alignlib::Alignment::moveAlignment )
                , ( bp::arg("row_offset"), bp::arg("col_offset") ) );
        
        }
        { //::alignlib::Alignment::removeColRegion
        
            typedef void ( ::alignlib::Alignment::*removeColRegion_function_type )( ::alignlib::Position,::alignlib::Position ) ;
            
            Alignment_exposer.def( 
                "removeColRegion"
                , removeColRegion_function_type( &::alignlib::Alignment::removeColRegion )
                , ( bp::arg("from"), bp::arg("to") ) );
        
        }
        { //::alignlib::Alignment::removePair
        
            typedef void ( ::alignlib::Alignment::*removePair_function_type )( ::alignlib::ResiduePair const & ) ;
            
            Alignment_exposer.def( 
                "removePair"
                , removePair_function_type( &::alignlib::Alignment::removePair )
                , ( bp::arg("pair") ) );
        
        }
        { //::alignlib::Alignment::removeRowRegion
        
            typedef void ( ::alignlib::Alignment::*removeRowRegion_function_type )( ::alignlib::Position,::alignlib::Position ) ;
            
            Alignment_exposer.def( 
                "removeRowRegion"
                , removeRowRegion_function_type( &::alignlib::Alignment::removeRowRegion )
                , ( bp::arg("from"), bp::arg("to") ) );
        
        }
        { //::alignlib::Alignment::setScore
        
            typedef void ( ::alignlib::Alignment::*setScore_function_type )( ::alignlib::Score ) ;
            
            Alignment_exposer.def( 
                "setScore"
                , setScore_function_type( &::alignlib::Alignment::setScore )
                , ( bp::arg("score") ) );
        
        }
        { //::alignlib::Alignment::switchRowCol
        
            typedef void ( ::alignlib::Alignment::*switchRowCol_function_type )(  ) ;
            
            Alignment_exposer.def( 
                "switchRowCol"
                , switchRowCol_function_type( &::alignlib::Alignment::switchRowCol ) );
        
        }
        { //::alignlib::Alignment::write
        
            typedef void ( ::alignlib::Alignment::*write_function_type )( ::std::ostream & ) const;
            
            Alignment_exposer.def( 
                "write"
                , write_function_type( &::alignlib::Alignment::write )
                , ( bp::arg("output") ) );
        
        }
        Alignment_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Alignment > >();
    }

    { //::alignlib::AlignmentFormat
        typedef bp::class_< AlignmentFormat_wrapper > AlignmentFormat_exposer_t;
        AlignmentFormat_exposer_t AlignmentFormat_exposer = AlignmentFormat_exposer_t( "AlignmentFormat" );
        bp::scope AlignmentFormat_scope( AlignmentFormat_exposer );
        AlignmentFormat_exposer.def( bp::init< >() );
        AlignmentFormat_exposer.def( bp::init< alignlib::HAlignment const & >(( bp::arg("src") )) );
        AlignmentFormat_exposer.def( bp::init< std::istream & >(( bp::arg("src") )) );
        AlignmentFormat_exposer.def( bp::init< std::string const & >(( bp::arg("src") )) );
        AlignmentFormat_exposer.def( bp::init< alignlib::AlignmentFormat const & >(( bp::arg("arg0") )) );
        { //::alignlib::AlignmentFormat::copy
        
            typedef void ( ::alignlib::AlignmentFormat::*copy_function_type )( ::alignlib::HAlignment & ) const;
            typedef void ( AlignmentFormat_wrapper::*default_copy_function_type )( ::alignlib::HAlignment & ) const;
            
            AlignmentFormat_exposer.def( 
                "copy"
                , copy_function_type(&::alignlib::AlignmentFormat::copy)
                , default_copy_function_type(&AlignmentFormat_wrapper::default_copy)
                , ( bp::arg("dest") ) );
        
        }
        { //::alignlib::AlignmentFormat::fill
        
            typedef void ( ::alignlib::AlignmentFormat::*fill_function_type )( ::alignlib::HAlignment const & ) ;
            typedef void ( AlignmentFormat_wrapper::*default_fill_function_type )( ::alignlib::HAlignment const & ) ;
            
            AlignmentFormat_exposer.def( 
                "fill"
                , fill_function_type(&::alignlib::AlignmentFormat::fill)
                , default_fill_function_type(&AlignmentFormat_wrapper::default_fill)
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::AlignmentFormat::load
        
            typedef void ( ::alignlib::AlignmentFormat::*load_function_type )( ::std::istream & ) ;
            typedef void ( AlignmentFormat_wrapper::*default_load_function_type )( ::std::istream & ) ;
            
            AlignmentFormat_exposer.def( 
                "load"
                , load_function_type(&::alignlib::AlignmentFormat::load)
                , default_load_function_type(&AlignmentFormat_wrapper::default_load)
                , ( bp::arg("arg0") ) );
        
        }
        { //::alignlib::AlignmentFormat::save
        
            typedef void ( ::alignlib::AlignmentFormat::*save_function_type )( ::std::ostream & ) const;
            typedef void ( AlignmentFormat_wrapper::*default_save_function_type )( ::std::ostream & ) const;
            
            AlignmentFormat_exposer.def( 
                "save"
                , save_function_type(&::alignlib::AlignmentFormat::save)
                , default_save_function_type(&AlignmentFormat_wrapper::default_save)
                , ( bp::arg("arg0") ) );
        
        }
        AlignmentFormat_exposer.def_readwrite( "mColFrom", &alignlib::AlignmentFormat::mColFrom );
        AlignmentFormat_exposer.def_readwrite( "mColTo", &alignlib::AlignmentFormat::mColTo );
        AlignmentFormat_exposer.def_readwrite( "mRowFrom", &alignlib::AlignmentFormat::mRowFrom );
        AlignmentFormat_exposer.def_readwrite( "mRowTo", &alignlib::AlignmentFormat::mRowTo );
        AlignmentFormat_exposer.def( bp::self_ns::str( bp::self ) );
    }

    bp::implicitly_convertible< alignlib::HAlignment const &, alignlib::AlignmentFormat >();

    bp::implicitly_convertible< std::istream &, alignlib::AlignmentFormat >();

    bp::implicitly_convertible< std::string const &, alignlib::AlignmentFormat >();

    { //::alignlib::AlignmentFormatBlocks
        typedef bp::class_< AlignmentFormatBlocks_wrapper, bp::bases< alignlib::AlignmentFormat > > AlignmentFormatBlocks_exposer_t;
        AlignmentFormatBlocks_exposer_t AlignmentFormatBlocks_exposer = AlignmentFormatBlocks_exposer_t( "AlignmentFormatBlocks" );
        bp::scope AlignmentFormatBlocks_scope( AlignmentFormatBlocks_exposer );
        AlignmentFormatBlocks_exposer.def( bp::init< >() );
        AlignmentFormatBlocks_exposer.def( bp::init< alignlib::HAlignment const & >(( bp::arg("src") )) );
        AlignmentFormatBlocks_exposer.def( bp::init< std::istream & >(( bp::arg("src") )) );
        AlignmentFormatBlocks_exposer.def( bp::init< std::string const & >(( bp::arg("src") )) );
        AlignmentFormatBlocks_exposer.def( bp::init< alignlib::AlignmentFormatBlocks const & >(( bp::arg("arg0") )) );
        { //::alignlib::AlignmentFormatBlocks::copy
        
            typedef void ( ::alignlib::AlignmentFormatBlocks::*copy_function_type )( ::alignlib::HAlignment & ) const;
            typedef void ( AlignmentFormatBlocks_wrapper::*default_copy_function_type )( ::alignlib::HAlignment & ) const;
            
            AlignmentFormatBlocks_exposer.def( 
                "copy"
                , copy_function_type(&::alignlib::AlignmentFormatBlocks::copy)
                , default_copy_function_type(&AlignmentFormatBlocks_wrapper::default_copy)
                , ( bp::arg("dest") ) );
        
        }
        { //::alignlib::AlignmentFormatBlocks::fill
        
            typedef void ( ::alignlib::AlignmentFormatBlocks::*fill_function_type )( ::alignlib::HAlignment const & ) ;
            typedef void ( AlignmentFormatBlocks_wrapper::*default_fill_function_type )( ::alignlib::HAlignment const & ) ;
            
            AlignmentFormatBlocks_exposer.def( 
                "fill"
                , fill_function_type(&::alignlib::AlignmentFormatBlocks::fill)
                , default_fill_function_type(&AlignmentFormatBlocks_wrapper::default_fill)
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::AlignmentFormatBlocks::load
        
            typedef void ( ::alignlib::AlignmentFormatBlocks::*load_function_type )( ::std::istream & ) ;
            typedef void ( AlignmentFormatBlocks_wrapper::*default_load_function_type )( ::std::istream & ) ;
            
            AlignmentFormatBlocks_exposer.def( 
                "load"
                , load_function_type(&::alignlib::AlignmentFormatBlocks::load)
                , default_load_function_type(&AlignmentFormatBlocks_wrapper::default_load)
                , ( bp::arg("arg0") ) );
        
        }
        { //::alignlib::AlignmentFormatBlocks::save
        
            typedef void ( ::alignlib::AlignmentFormatBlocks::*save_function_type )( ::std::ostream & ) const;
            typedef void ( AlignmentFormatBlocks_wrapper::*default_save_function_type )( ::std::ostream & ) const;
            
            AlignmentFormatBlocks_exposer.def( 
                "save"
                , save_function_type(&::alignlib::AlignmentFormatBlocks::save)
                , default_save_function_type(&AlignmentFormatBlocks_wrapper::default_save)
                , ( bp::arg("arg0") ) );
        
        }
        AlignmentFormatBlocks_exposer.def_readwrite( "mBlockSizes", &alignlib::AlignmentFormatBlocks::mBlockSizes );
        AlignmentFormatBlocks_exposer.def_readwrite( "mColStarts", &alignlib::AlignmentFormatBlocks::mColStarts );
        AlignmentFormatBlocks_exposer.def_readwrite( "mRowStarts", &alignlib::AlignmentFormatBlocks::mRowStarts );
    }

    bp::implicitly_convertible< alignlib::HAlignment const &, alignlib::AlignmentFormatBlocks >();

    bp::implicitly_convertible< std::istream &, alignlib::AlignmentFormatBlocks >();

    bp::implicitly_convertible< std::string const &, alignlib::AlignmentFormatBlocks >();

    { //::alignlib::AlignmentFormatDiagonals
        typedef bp::class_< AlignmentFormatDiagonals_wrapper, bp::bases< alignlib::AlignmentFormat > > AlignmentFormatDiagonals_exposer_t;
        AlignmentFormatDiagonals_exposer_t AlignmentFormatDiagonals_exposer = AlignmentFormatDiagonals_exposer_t( "AlignmentFormatDiagonals" );
        bp::scope AlignmentFormatDiagonals_scope( AlignmentFormatDiagonals_exposer );
        AlignmentFormatDiagonals_exposer.def( bp::init< >() );
        AlignmentFormatDiagonals_exposer.def( bp::init< alignlib::HAlignment const & >(( bp::arg("src") )) );
        AlignmentFormatDiagonals_exposer.def( bp::init< std::istream & >(( bp::arg("src") )) );
        AlignmentFormatDiagonals_exposer.def( bp::init< std::string const & >(( bp::arg("src") )) );
        AlignmentFormatDiagonals_exposer.def( bp::init< alignlib::AlignmentFormatDiagonals const & >(( bp::arg("arg0") )) );
        { //::alignlib::AlignmentFormatDiagonals::copy
        
            typedef void ( ::alignlib::AlignmentFormatDiagonals::*copy_function_type )( ::alignlib::HAlignment &,bool const ) const;
            typedef void ( AlignmentFormatDiagonals_wrapper::*default_copy_function_type )( ::alignlib::HAlignment &,bool const ) const;
            
            AlignmentFormatDiagonals_exposer.def( 
                "copy"
                , copy_function_type(&::alignlib::AlignmentFormatDiagonals::copy)
                , default_copy_function_type(&AlignmentFormatDiagonals_wrapper::default_copy)
                , ( bp::arg("dest"), bp::arg("reverse") ) );
        
        }
        { //::alignlib::AlignmentFormatDiagonals::copy
        
            typedef void ( ::alignlib::AlignmentFormatDiagonals::*copy_function_type )( ::alignlib::HAlignment & ) const;
            typedef void ( AlignmentFormatDiagonals_wrapper::*default_copy_function_type )( ::alignlib::HAlignment & ) const;
            
            AlignmentFormatDiagonals_exposer.def( 
                "copy"
                , copy_function_type(&::alignlib::AlignmentFormatDiagonals::copy)
                , default_copy_function_type(&AlignmentFormatDiagonals_wrapper::default_copy)
                , ( bp::arg("dest") ) );
        
        }
        { //::alignlib::AlignmentFormatDiagonals::fill
        
            typedef void ( ::alignlib::AlignmentFormatDiagonals::*fill_function_type )( ::alignlib::HAlignment const &,bool const,::alignlib::Position const,::alignlib::Position const,::alignlib::Position const,::alignlib::Position const,::alignlib::Diagonal const,::alignlib::Diagonal const ) ;
            typedef void ( AlignmentFormatDiagonals_wrapper::*default_fill_function_type )( ::alignlib::HAlignment const &,bool const,::alignlib::Position const,::alignlib::Position const,::alignlib::Position const,::alignlib::Position const,::alignlib::Diagonal const,::alignlib::Diagonal const ) ;
            
            AlignmentFormatDiagonals_exposer.def( 
                "fill"
                , fill_function_type(&::alignlib::AlignmentFormatDiagonals::fill)
                , default_fill_function_type(&AlignmentFormatDiagonals_wrapper::default_fill)
                , ( bp::arg("src"), bp::arg("reverse"), bp::arg("row_from")=(int const)(-1), bp::arg("row_to")=(int const)(-1), bp::arg("col_from")=(int const)(-1), bp::arg("col_to")=(int const)(-1), bp::arg("diagonal_from")=(long int const)(99999999), bp::arg("diagonal_to")=(long int const)(-99999999) ) );
        
        }
        { //::alignlib::AlignmentFormatDiagonals::fill
        
            typedef void ( ::alignlib::AlignmentFormatDiagonals::*fill_function_type )( ::alignlib::HAlignment const & ) ;
            typedef void ( AlignmentFormatDiagonals_wrapper::*default_fill_function_type )( ::alignlib::HAlignment const & ) ;
            
            AlignmentFormatDiagonals_exposer.def( 
                "fill"
                , fill_function_type(&::alignlib::AlignmentFormatDiagonals::fill)
                , default_fill_function_type(&AlignmentFormatDiagonals_wrapper::default_fill)
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::AlignmentFormatDiagonals::load
        
            typedef void ( ::alignlib::AlignmentFormatDiagonals::*load_function_type )( ::std::istream & ) ;
            typedef void ( AlignmentFormatDiagonals_wrapper::*default_load_function_type )( ::std::istream & ) ;
            
            AlignmentFormatDiagonals_exposer.def( 
                "load"
                , load_function_type(&::alignlib::AlignmentFormatDiagonals::load)
                , default_load_function_type(&AlignmentFormatDiagonals_wrapper::default_load)
                , ( bp::arg("arg0") ) );
        
        }
        { //::alignlib::AlignmentFormatDiagonals::save
        
            typedef void ( ::alignlib::AlignmentFormatDiagonals::*save_function_type )( ::std::ostream & ) const;
            typedef void ( AlignmentFormatDiagonals_wrapper::*default_save_function_type )( ::std::ostream & ) const;
            
            AlignmentFormatDiagonals_exposer.def( 
                "save"
                , save_function_type(&::alignlib::AlignmentFormatDiagonals::save)
                , default_save_function_type(&AlignmentFormatDiagonals_wrapper::default_save)
                , ( bp::arg("arg0") ) );
        
        }
        AlignmentFormatDiagonals_exposer.def_readwrite( "mAlignment", &alignlib::AlignmentFormatDiagonals::mAlignment );
    }

    bp::implicitly_convertible< alignlib::HAlignment const &, alignlib::AlignmentFormatDiagonals >();

    bp::implicitly_convertible< std::istream &, alignlib::AlignmentFormatDiagonals >();

    bp::implicitly_convertible< std::string const &, alignlib::AlignmentFormatDiagonals >();

    { //::alignlib::AlignmentFormatEmissions
        typedef bp::class_< AlignmentFormatEmissions_wrapper, bp::bases< alignlib::AlignmentFormat > > AlignmentFormatEmissions_exposer_t;
        AlignmentFormatEmissions_exposer_t AlignmentFormatEmissions_exposer = AlignmentFormatEmissions_exposer_t( "AlignmentFormatEmissions" );
        bp::scope AlignmentFormatEmissions_scope( AlignmentFormatEmissions_exposer );
        AlignmentFormatEmissions_exposer.def( bp::init< >() );
        AlignmentFormatEmissions_exposer.def( bp::init< alignlib::HAlignment const & >(( bp::arg("src") )) );
        AlignmentFormatEmissions_exposer.def( bp::init< std::istream & >(( bp::arg("src") )) );
        AlignmentFormatEmissions_exposer.def( bp::init< std::string const & >(( bp::arg("src") )) );
        AlignmentFormatEmissions_exposer.def( bp::init< alignlib::AlignmentFormatEmissions const & >(( bp::arg("arg0") )) );
        AlignmentFormatEmissions_exposer.def( bp::init< int, std::string const &, int, std::string const & >(( bp::arg("row_from"), bp::arg("row"), bp::arg("col_from"), bp::arg("col") )) );
        { //::alignlib::AlignmentFormatEmissions::copy
        
            typedef void ( ::alignlib::AlignmentFormatEmissions::*copy_function_type )( ::alignlib::HAlignment & ) const;
            typedef void ( AlignmentFormatEmissions_wrapper::*default_copy_function_type )( ::alignlib::HAlignment & ) const;
            
            AlignmentFormatEmissions_exposer.def( 
                "copy"
                , copy_function_type(&::alignlib::AlignmentFormatEmissions::copy)
                , default_copy_function_type(&AlignmentFormatEmissions_wrapper::default_copy)
                , ( bp::arg("dest") ) );
        
        }
        { //::alignlib::AlignmentFormatEmissions::fill
        
            typedef void ( ::alignlib::AlignmentFormatEmissions::*fill_function_type )( ::alignlib::HAlignment const & ) ;
            typedef void ( AlignmentFormatEmissions_wrapper::*default_fill_function_type )( ::alignlib::HAlignment const & ) ;
            
            AlignmentFormatEmissions_exposer.def( 
                "fill"
                , fill_function_type(&::alignlib::AlignmentFormatEmissions::fill)
                , default_fill_function_type(&AlignmentFormatEmissions_wrapper::default_fill)
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::AlignmentFormatEmissions::getNumEmissions
        
            typedef ::alignlib::Position ( ::alignlib::AlignmentFormatEmissions::*getNumEmissions_function_type )( ::std::string const & ) ;
            typedef ::alignlib::Position ( AlignmentFormatEmissions_wrapper::*default_getNumEmissions_function_type )( ::std::string const & ) ;
            
            AlignmentFormatEmissions_exposer.def( 
                "getNumEmissions"
                , getNumEmissions_function_type(&::alignlib::AlignmentFormatEmissions::getNumEmissions)
                , default_getNumEmissions_function_type(&AlignmentFormatEmissions_wrapper::default_getNumEmissions)
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::AlignmentFormatEmissions::load
        
            typedef void ( ::alignlib::AlignmentFormatEmissions::*load_function_type )( ::std::istream & ) ;
            typedef void ( AlignmentFormatEmissions_wrapper::*default_load_function_type )( ::std::istream & ) ;
            
            AlignmentFormatEmissions_exposer.def( 
                "load"
                , load_function_type(&::alignlib::AlignmentFormatEmissions::load)
                , default_load_function_type(&AlignmentFormatEmissions_wrapper::default_load)
                , ( bp::arg("arg0") ) );
        
        }
        { //::alignlib::AlignmentFormatEmissions::save
        
            typedef void ( ::alignlib::AlignmentFormatEmissions::*save_function_type )( ::std::ostream & ) const;
            typedef void ( AlignmentFormatEmissions_wrapper::*default_save_function_type )( ::std::ostream & ) const;
            
            AlignmentFormatEmissions_exposer.def( 
                "save"
                , save_function_type(&::alignlib::AlignmentFormatEmissions::save)
                , default_save_function_type(&AlignmentFormatEmissions_wrapper::default_save)
                , ( bp::arg("arg0") ) );
        
        }
        AlignmentFormatEmissions_exposer.def_readwrite( "mColAlignment", &alignlib::AlignmentFormatEmissions::mColAlignment );
        AlignmentFormatEmissions_exposer.def_readwrite( "mRowAlignment", &alignlib::AlignmentFormatEmissions::mRowAlignment );
    }

    bp::implicitly_convertible< alignlib::HAlignment const &, alignlib::AlignmentFormatEmissions >();

    bp::implicitly_convertible< std::istream &, alignlib::AlignmentFormatEmissions >();

    bp::implicitly_convertible< std::string const &, alignlib::AlignmentFormatEmissions >();

    { //::alignlib::AlignmentFormatExplicit
        typedef bp::class_< AlignmentFormatExplicit_wrapper, bp::bases< alignlib::AlignmentFormat > > AlignmentFormatExplicit_exposer_t;
        AlignmentFormatExplicit_exposer_t AlignmentFormatExplicit_exposer = AlignmentFormatExplicit_exposer_t( "AlignmentFormatExplicit" );
        bp::scope AlignmentFormatExplicit_scope( AlignmentFormatExplicit_exposer );
        AlignmentFormatExplicit_exposer.def( bp::init< >() );
        AlignmentFormatExplicit_exposer.def( bp::init< alignlib::HAlignment const &, alignlib::HAlignandum const &, alignlib::HAlignandum const & >(( bp::arg("src"), bp::arg("row"), bp::arg("col") )) );
        AlignmentFormatExplicit_exposer.def( bp::init< std::istream & >(( bp::arg("src") )) );
        AlignmentFormatExplicit_exposer.def( bp::init< std::string const & >(( bp::arg("src") )) );
        AlignmentFormatExplicit_exposer.def( bp::init< int, std::string const &, int, std::string const & >(( bp::arg("row_from"), bp::arg("row"), bp::arg("col_from"), bp::arg("col") )) );
        AlignmentFormatExplicit_exposer.def( bp::init< alignlib::AlignmentFormatExplicit const & >(( bp::arg("arg0") )) );
        { //::alignlib::AlignmentFormatExplicit::copy
        
            typedef void ( ::alignlib::AlignmentFormatExplicit::*copy_function_type )( ::alignlib::HAlignment & ) const;
            typedef void ( AlignmentFormatExplicit_wrapper::*default_copy_function_type )( ::alignlib::HAlignment & ) const;
            
            AlignmentFormatExplicit_exposer.def( 
                "copy"
                , copy_function_type(&::alignlib::AlignmentFormatExplicit::copy)
                , default_copy_function_type(&AlignmentFormatExplicit_wrapper::default_copy)
                , ( bp::arg("dest") ) );
        
        }
        { //::alignlib::AlignmentFormatExplicit::fill
        
            typedef void ( ::alignlib::AlignmentFormatExplicit::*fill_function_type )( ::alignlib::HAlignment const &,::alignlib::HAlignandum const &,::alignlib::HAlignandum const & ) ;
            typedef void ( AlignmentFormatExplicit_wrapper::*default_fill_function_type )( ::alignlib::HAlignment const &,::alignlib::HAlignandum const &,::alignlib::HAlignandum const & ) ;
            
            AlignmentFormatExplicit_exposer.def( 
                "fill"
                , fill_function_type(&::alignlib::AlignmentFormatExplicit::fill)
                , default_fill_function_type(&AlignmentFormatExplicit_wrapper::default_fill)
                , ( bp::arg("src"), bp::arg("row"), bp::arg("col") ) );
        
        }
        { //::alignlib::AlignmentFormatExplicit::load
        
            typedef void ( ::alignlib::AlignmentFormatExplicit::*load_function_type )( ::std::istream & ) ;
            typedef void ( AlignmentFormatExplicit_wrapper::*default_load_function_type )( ::std::istream & ) ;
            
            AlignmentFormatExplicit_exposer.def( 
                "load"
                , load_function_type(&::alignlib::AlignmentFormatExplicit::load)
                , default_load_function_type(&AlignmentFormatExplicit_wrapper::default_load)
                , ( bp::arg("arg0") ) );
        
        }
        { //::alignlib::AlignmentFormatExplicit::save
        
            typedef void ( ::alignlib::AlignmentFormatExplicit::*save_function_type )( ::std::ostream & ) const;
            typedef void ( AlignmentFormatExplicit_wrapper::*default_save_function_type )( ::std::ostream & ) const;
            
            AlignmentFormatExplicit_exposer.def( 
                "save"
                , save_function_type(&::alignlib::AlignmentFormatExplicit::save)
                , default_save_function_type(&AlignmentFormatExplicit_wrapper::default_save)
                , ( bp::arg("arg0") ) );
        
        }
        AlignmentFormatExplicit_exposer.def_readwrite( "mColAlignment", &alignlib::AlignmentFormatExplicit::mColAlignment );
        AlignmentFormatExplicit_exposer.def_readwrite( "mRowAlignment", &alignlib::AlignmentFormatExplicit::mRowAlignment );
    }

    bp::implicitly_convertible< std::istream &, alignlib::AlignmentFormatExplicit >();

    bp::implicitly_convertible< std::string const &, alignlib::AlignmentFormatExplicit >();

    { //::alignlib::AlignmentIterator
        typedef bp::class_< alignlib::AlignmentIterator > AlignmentIterator_exposer_t;
        AlignmentIterator_exposer_t AlignmentIterator_exposer = AlignmentIterator_exposer_t( "AlignmentIterator" );
        bp::scope AlignmentIterator_scope( AlignmentIterator_exposer );
        AlignmentIterator_exposer.def( bp::self != bp::self );
        { //::alignlib::AlignmentIterator::operator=
        
            typedef ::alignlib::AlignmentIterator & ( ::alignlib::AlignmentIterator::*assign_function_type )( ::alignlib::AlignmentIterator const & ) ;
            
            AlignmentIterator_exposer.def( 
                "assign"
                , assign_function_type( &::alignlib::AlignmentIterator::operator= )
                , ( bp::arg("other") )
                , bp::return_self< >() );
        
        }
        AlignmentIterator_exposer.def( bp::self == bp::self );
    }

    { //::alignlib::Coordinate
        typedef bp::class_< alignlib::Coordinate > Coordinate_exposer_t;
        Coordinate_exposer_t Coordinate_exposer = Coordinate_exposer_t( "Coordinate" );
        bp::scope Coordinate_scope( Coordinate_exposer );
        Coordinate_exposer.def_readwrite( "col", &alignlib::Coordinate::col );
        Coordinate_exposer.def_readwrite( "row", &alignlib::Coordinate::row );
    }

    { //::alignlib::DistanceMatrix
        typedef bp::class_< alignlib::DistanceMatrix, boost::noncopyable > DistanceMatrix_exposer_t;
        DistanceMatrix_exposer_t DistanceMatrix_exposer = DistanceMatrix_exposer_t( "DistanceMatrix", bp::no_init );
        bp::scope DistanceMatrix_scope( DistanceMatrix_exposer );
        { //::alignlib::DistanceMatrix::getElement
        
            typedef ::alignlib::DistanceMatrixValue ( ::alignlib::DistanceMatrix::*getElement_function_type )( ::alignlib::DistanceMatrixSize,::alignlib::DistanceMatrixSize ) const;
            
            DistanceMatrix_exposer.def( 
                "getElement"
                , getElement_function_type( &::alignlib::DistanceMatrix::getElement )
                , ( bp::arg("row"), bp::arg("col") ) );
        
        }
        { //::alignlib::DistanceMatrix::getMaximum
        
            typedef ::alignlib::DistanceMatrixValue ( ::alignlib::DistanceMatrix::*getMaximum_function_type )(  ) const;
            
            DistanceMatrix_exposer.def( 
                "getMaximum"
                , getMaximum_function_type( &::alignlib::DistanceMatrix::getMaximum ) );
        
        }
        { //::alignlib::DistanceMatrix::getMaximum
        
            typedef ::alignlib::DistanceMatrixValue ( ::alignlib::DistanceMatrix::*getMaximum_function_type )( ::alignlib::Coordinate & ) const;
            
            DistanceMatrix_exposer.def( 
                "getMaximum"
                , getMaximum_function_type( &::alignlib::DistanceMatrix::getMaximum )
                , ( bp::arg("dest") ) );
        
        }
        { //::alignlib::DistanceMatrix::getMinimum
        
            typedef ::alignlib::DistanceMatrixValue ( ::alignlib::DistanceMatrix::*getMinimum_function_type )(  ) const;
            
            DistanceMatrix_exposer.def( 
                "getMinimum"
                , getMinimum_function_type( &::alignlib::DistanceMatrix::getMinimum ) );
        
        }
        { //::alignlib::DistanceMatrix::getMinimum
        
            typedef ::alignlib::DistanceMatrixValue ( ::alignlib::DistanceMatrix::*getMinimum_function_type )( ::alignlib::Coordinate & ) const;
            
            DistanceMatrix_exposer.def( 
                "getMinimum"
                , getMinimum_function_type( &::alignlib::DistanceMatrix::getMinimum )
                , ( bp::arg("dest") ) );
        
        }
        { //::alignlib::DistanceMatrix::getSize
        
            typedef ::alignlib::DistanceMatrixSize ( ::alignlib::DistanceMatrix::*getSize_function_type )(  ) const;
            
            DistanceMatrix_exposer.def( 
                "getSize"
                , getSize_function_type( &::alignlib::DistanceMatrix::getSize ) );
        
        }
        { //::alignlib::DistanceMatrix::getWidth
        
            typedef ::alignlib::DistanceMatrixSize ( ::alignlib::DistanceMatrix::*getWidth_function_type )(  ) const;
            
            DistanceMatrix_exposer.def( 
                "getWidth"
                , getWidth_function_type( &::alignlib::DistanceMatrix::getWidth ) );
        
        }
        { //::alignlib::DistanceMatrix::read
        
            typedef void ( ::alignlib::DistanceMatrix::*read_function_type )( ::std::istream & ) const;
            
            DistanceMatrix_exposer.def( 
                "read"
                , read_function_type( &::alignlib::DistanceMatrix::read )
                , ( bp::arg("input") ) );
        
        }
        { //::alignlib::DistanceMatrix::setElement
        
            typedef void ( ::alignlib::DistanceMatrix::*setElement_function_type )( ::alignlib::DistanceMatrixSize,::alignlib::DistanceMatrixSize,::alignlib::DistanceMatrixValue ) ;
            
            DistanceMatrix_exposer.def( 
                "setElement"
                , setElement_function_type( &::alignlib::DistanceMatrix::setElement )
                , ( bp::arg("row"), bp::arg("col"), bp::arg("value") ) );
        
        }
        { //::alignlib::DistanceMatrix::setWidth
        
            typedef void ( ::alignlib::DistanceMatrix::*setWidth_function_type )( ::alignlib::DistanceMatrixSize ) ;
            
            DistanceMatrix_exposer.def( 
                "setWidth"
                , setWidth_function_type( &::alignlib::DistanceMatrix::setWidth )
                , ( bp::arg("width") ) );
        
        }
        { //::alignlib::DistanceMatrix::shrink
        
            typedef void ( ::alignlib::DistanceMatrix::*shrink_function_type )(  ) ;
            
            DistanceMatrix_exposer.def( 
                "shrink"
                , shrink_function_type( &::alignlib::DistanceMatrix::shrink ) );
        
        }
        { //::alignlib::DistanceMatrix::swap
        
            typedef void ( ::alignlib::DistanceMatrix::*swap_function_type )( ::alignlib::DistanceMatrixSize,::alignlib::DistanceMatrixSize ) ;
            
            DistanceMatrix_exposer.def( 
                "swap"
                , swap_function_type( &::alignlib::DistanceMatrix::swap )
                , ( bp::arg("a"), bp::arg("b") ) );
        
        }
        { //::alignlib::DistanceMatrix::write
        
            typedef void ( ::alignlib::DistanceMatrix::*write_function_type )( ::std::ostream & ) const;
            
            DistanceMatrix_exposer.def( 
                "write"
                , write_function_type( &::alignlib::DistanceMatrix::write )
                , ( bp::arg("output") ) );
        
        }
        DistanceMatrix_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::DistanceMatrix > >();
    }

    { //::alignlib::Distor
        typedef bp::class_< alignlib::Distor, boost::noncopyable > Distor_exposer_t;
        Distor_exposer_t Distor_exposer = Distor_exposer_t( "Distor", bp::no_init );
        bp::scope Distor_scope( Distor_exposer );
        { //::alignlib::Distor::calculateDistance
        
            typedef ::alignlib::DistanceMatrixValue ( ::alignlib::Distor::*calculateDistance_function_type )( ::std::string const &,::std::string const & ) const;
            
            Distor_exposer.def( 
                "calculateDistance"
                , calculateDistance_function_type( &::alignlib::Distor::calculateDistance )
                , ( bp::arg("s_row_1"), bp::arg("s_row_2") ) );
        
        }
        { //::alignlib::Distor::calculateMatrix
        
            typedef void ( ::alignlib::Distor::*calculateMatrix_function_type )( ::alignlib::HDistanceMatrix &,::alignlib::HMultipleAlignment const & ) const;
            
            Distor_exposer.def( 
                "calculateMatrix"
                , calculateMatrix_function_type( &::alignlib::Distor::calculateMatrix )
                , ( bp::arg("dest"), bp::arg("mali") ) );
        
        }
        { //::alignlib::Distor::getMaximumPossibleDistance
        
            typedef ::alignlib::DistanceMatrixValue ( ::alignlib::Distor::*getMaximumPossibleDistance_function_type )(  ) const;
            
            Distor_exposer.def( 
                "getMaximumPossibleDistance"
                , getMaximumPossibleDistance_function_type( &::alignlib::Distor::getMaximumPossibleDistance ) );
        
        }
        Distor_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Distor > >();
    }

    { //::alignlib::EVDParameters
        typedef bp::class_< alignlib::EVDParameters > EVDParameters_exposer_t;
        EVDParameters_exposer_t EVDParameters_exposer = EVDParameters_exposer_t( "EVDParameters" );
        bp::scope EVDParameters_scope( EVDParameters_exposer );
        { //::alignlib::EVDParameters::getK
        
            typedef double ( ::alignlib::EVDParameters::*getK_function_type )(  ) ;
            
            EVDParameters_exposer.def( 
                "getK"
                , getK_function_type( &::alignlib::EVDParameters::getK ) );
        
        }
        { //::alignlib::EVDParameters::getLambda
        
            typedef double ( ::alignlib::EVDParameters::*getLambda_function_type )(  ) ;
            
            EVDParameters_exposer.def( 
                "getLambda"
                , getLambda_function_type( &::alignlib::EVDParameters::getLambda ) );
        
        }
        EVDParameters_exposer.def_readwrite( "mK", &alignlib::EVDParameters::mK );
        EVDParameters_exposer.def_readwrite( "mLambda", &alignlib::EVDParameters::mLambda );
    }

    { //::alignlib::Encoder
        typedef bp::class_< alignlib::Encoder, boost::noncopyable > Encoder_exposer_t;
        Encoder_exposer_t Encoder_exposer = Encoder_exposer_t( "Encoder", bp::no_init );
        bp::scope Encoder_scope( Encoder_exposer );
        { //::alignlib::Encoder::countChars
        
            typedef ::alignlib::Position ( ::alignlib::Encoder::*countChars_function_type )( ::std::string const & ) const;
            
            Encoder_exposer.def( 
                "countChars"
                , countChars_function_type( &::alignlib::Encoder::countChars )
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::Encoder::decode
        
            typedef ::std::string ( ::alignlib::Encoder::*decode_function_type )( ::alignlib::ResidueVector const & ) const;
            
            Encoder_exposer.def( 
                "decode"
                , decode_function_type( &::alignlib::Encoder::decode )
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::Encoder::decode
        
            typedef char ( ::alignlib::Encoder::*decode_function_type )( ::alignlib::Residue const ) const;
            
            Encoder_exposer.def( 
                "decode"
                , decode_function_type( &::alignlib::Encoder::decode )
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::Encoder::encode
        
            typedef ::alignlib::ResidueVector ( ::alignlib::Encoder::*encode_function_type )( ::std::string const & ) const;
            
            Encoder_exposer.def( 
                "encode"
                , encode_function_type( &::alignlib::Encoder::encode )
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::Encoder::encode
        
            typedef ::alignlib::Residue ( ::alignlib::Encoder::*encode_function_type )( char const ) const;
            
            Encoder_exposer.def( 
                "encode"
                , encode_function_type( &::alignlib::Encoder::encode )
                , ( bp::arg("arg0") ) );
        
        }
        { //::alignlib::Encoder::getAlphabet
        
            typedef ::std::string ( ::alignlib::Encoder::*getAlphabet_function_type )(  ) const;
            
            Encoder_exposer.def( 
                "getAlphabet"
                , getAlphabet_function_type( &::alignlib::Encoder::getAlphabet ) );
        
        }
        { //::alignlib::Encoder::getAlphabetSize
        
            typedef int ( ::alignlib::Encoder::*getAlphabetSize_function_type )(  ) const;
            
            Encoder_exposer.def( 
                "getAlphabetSize"
                , getAlphabetSize_function_type( &::alignlib::Encoder::getAlphabetSize ) );
        
        }
        { //::alignlib::Encoder::getAlphabetType
        
            typedef ::alignlib::AlphabetType ( ::alignlib::Encoder::*getAlphabetType_function_type )(  ) const;
            
            Encoder_exposer.def( 
                "getAlphabetType"
                , getAlphabetType_function_type( &::alignlib::Encoder::getAlphabetType ) );
        
        }
        { //::alignlib::Encoder::getGapChar
        
            typedef char ( ::alignlib::Encoder::*getGapChar_function_type )(  ) const;
            
            Encoder_exposer.def( 
                "getGapChar"
                , getGapChar_function_type( &::alignlib::Encoder::getGapChar ) );
        
        }
        { //::alignlib::Encoder::getGapChars
        
            typedef ::std::string ( ::alignlib::Encoder::*getGapChars_function_type )(  ) const;
            
            Encoder_exposer.def( 
                "getGapChars"
                , getGapChars_function_type( &::alignlib::Encoder::getGapChars ) );
        
        }
        { //::alignlib::Encoder::getGapCode
        
            typedef ::alignlib::Residue ( ::alignlib::Encoder::*getGapCode_function_type )(  ) const;
            
            Encoder_exposer.def( 
                "getGapCode"
                , getGapCode_function_type( &::alignlib::Encoder::getGapCode ) );
        
        }
        { //::alignlib::Encoder::getMaskChar
        
            typedef char ( ::alignlib::Encoder::*getMaskChar_function_type )(  ) const;
            
            Encoder_exposer.def( 
                "getMaskChar"
                , getMaskChar_function_type( &::alignlib::Encoder::getMaskChar ) );
        
        }
        { //::alignlib::Encoder::getMaskChars
        
            typedef ::std::string ( ::alignlib::Encoder::*getMaskChars_function_type )(  ) const;
            
            Encoder_exposer.def( 
                "getMaskChars"
                , getMaskChars_function_type( &::alignlib::Encoder::getMaskChars ) );
        
        }
        { //::alignlib::Encoder::getMaskCode
        
            typedef ::alignlib::Residue ( ::alignlib::Encoder::*getMaskCode_function_type )(  ) const;
            
            Encoder_exposer.def( 
                "getMaskCode"
                , getMaskCode_function_type( &::alignlib::Encoder::getMaskCode ) );
        
        }
        { //::alignlib::Encoder::isValidChar
        
            typedef bool ( ::alignlib::Encoder::*isValidChar_function_type )( char const ) const;
            
            Encoder_exposer.def( 
                "isValidChar"
                , isValidChar_function_type( &::alignlib::Encoder::isValidChar )
                , ( bp::arg("c") ) );
        
        }
        { //::alignlib::Encoder::map
        
            typedef ::alignlib::HResidueVector ( ::alignlib::Encoder::*map_function_type )( ::alignlib::HEncoder const & ) const;
            
            Encoder_exposer.def( 
                "map"
                , map_function_type( &::alignlib::Encoder::map )
                , ( bp::arg("other") ) );
        
        }
        { //::alignlib::Encoder::write
        
            typedef void ( ::alignlib::Encoder::*write_function_type )( ::std::ostream & ) const;
            
            Encoder_exposer.def( 
                "write"
                , write_function_type( &::alignlib::Encoder::write )
                , ( bp::arg("arg0") ) );
        
        }
        Encoder_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Encoder > >();
        Encoder_exposer.def( "save", wrapper_for_save<alignlib::Encoder> );
    }

    { //::alignlib::Fragmentor
        typedef bp::class_< alignlib::Fragmentor, boost::noncopyable > Fragmentor_exposer_t;
        Fragmentor_exposer_t Fragmentor_exposer = Fragmentor_exposer_t( "Fragmentor", bp::no_init );
        bp::scope Fragmentor_scope( Fragmentor_exposer );
        { //::alignlib::Fragmentor::fragment
        
            typedef ::alignlib::HFragmentVector ( ::alignlib::Fragmentor::*fragment_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignandum const &,::alignlib::HAlignandum const & ) ;
            
            Fragmentor_exposer.def( 
                "fragment"
                , fragment_function_type( &::alignlib::Fragmentor::fragment )
                , ( bp::arg("dest"), bp::arg("row"), bp::arg("col") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Fragmentor > >();
    }

    { //::alignlib::Iterator2D
        typedef bp::class_< alignlib::Iterator2D, boost::noncopyable > Iterator2D_exposer_t;
        Iterator2D_exposer_t Iterator2D_exposer = Iterator2D_exposer_t( "Iterator2D", bp::no_init );
        bp::scope Iterator2D_scope( Iterator2D_exposer );
        { //::alignlib::Iterator2D::col_back
        
            typedef ::alignlib::Position ( ::alignlib::Iterator2D::*col_back_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "col_back"
                , col_back_function_type( &::alignlib::Iterator2D::col_back )
                , ( bp::arg("row")=(int)(-1) ) );
        
        }
        { //::alignlib::Iterator2D::col_begin
        
            typedef ::alignlib::const_countable_iterator<int> ( ::alignlib::Iterator2D::*col_begin_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "col_begin"
                , col_begin_function_type( &::alignlib::Iterator2D::col_begin )
                , ( bp::arg("row")=(int)(-1) ) );
        
        }
        { //::alignlib::Iterator2D::col_end
        
            typedef ::alignlib::const_countable_iterator<int> ( ::alignlib::Iterator2D::*col_end_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "col_end"
                , col_end_function_type( &::alignlib::Iterator2D::col_end )
                , ( bp::arg("row")=(int)(-1) ) );
        
        }
        { //::alignlib::Iterator2D::col_front
        
            typedef ::alignlib::Position ( ::alignlib::Iterator2D::*col_front_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "col_front"
                , col_front_function_type( &::alignlib::Iterator2D::col_front )
                , ( bp::arg("row")=(int)(-1) ) );
        
        }
        { //::alignlib::Iterator2D::col_size
        
            typedef ::alignlib::Position ( ::alignlib::Iterator2D::*col_size_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "col_size"
                , col_size_function_type( &::alignlib::Iterator2D::col_size )
                , ( bp::arg("row")=(int)(-1) ) );
        
        }
        { //::alignlib::Iterator2D::getClone
        
            typedef ::alignlib::HIterator2D ( ::alignlib::Iterator2D::*getClone_function_type )(  ) const;
            
            Iterator2D_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::Iterator2D::getClone ) );
        
        }
        { //::alignlib::Iterator2D::getNew
        
            typedef ::alignlib::HIterator2D ( ::alignlib::Iterator2D::*getNew_function_type )( ::alignlib::HAlignandum const &,::alignlib::HAlignandum const & ) const;
            
            Iterator2D_exposer.def( 
                "getNew"
                , getNew_function_type( &::alignlib::Iterator2D::getNew )
                , ( bp::arg("row"), bp::arg("col") ) );
        
        }
        { //::alignlib::Iterator2D::resetRanges
        
            typedef void ( ::alignlib::Iterator2D::*resetRanges_function_type )( ::alignlib::HAlignandum const &,::alignlib::HAlignandum const & ) ;
            
            Iterator2D_exposer.def( 
                "resetRanges"
                , resetRanges_function_type( &::alignlib::Iterator2D::resetRanges )
                , ( bp::arg("row"), bp::arg("col") ) );
        
        }
        { //::alignlib::Iterator2D::row_back
        
            typedef ::alignlib::Position ( ::alignlib::Iterator2D::*row_back_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "row_back"
                , row_back_function_type( &::alignlib::Iterator2D::row_back )
                , ( bp::arg("col")=(int)(-1) ) );
        
        }
        { //::alignlib::Iterator2D::row_begin
        
            typedef ::alignlib::const_countable_iterator<int> ( ::alignlib::Iterator2D::*row_begin_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "row_begin"
                , row_begin_function_type( &::alignlib::Iterator2D::row_begin )
                , ( bp::arg("col")=(int)(-1) ) );
        
        }
        { //::alignlib::Iterator2D::row_end
        
            typedef ::alignlib::const_countable_iterator<int> ( ::alignlib::Iterator2D::*row_end_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "row_end"
                , row_end_function_type( &::alignlib::Iterator2D::row_end )
                , ( bp::arg("col")=(int)(-1) ) );
        
        }
        { //::alignlib::Iterator2D::row_front
        
            typedef ::alignlib::Position ( ::alignlib::Iterator2D::*row_front_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "row_front"
                , row_front_function_type( &::alignlib::Iterator2D::row_front )
                , ( bp::arg("col")=(int)(-1) ) );
        
        }
        { //::alignlib::Iterator2D::row_size
        
            typedef ::alignlib::Position ( ::alignlib::Iterator2D::*row_size_function_type )( ::alignlib::Position ) const;
            
            Iterator2D_exposer.def( 
                "row_size"
                , row_size_function_type( &::alignlib::Iterator2D::row_size )
                , ( bp::arg("col")=(int)(-1) ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Iterator2D > >();
    }

    { //::alignlib::LogOddor
        typedef bp::class_< alignlib::LogOddor, boost::noncopyable > LogOddor_exposer_t;
        LogOddor_exposer_t LogOddor_exposer = LogOddor_exposer_t( "LogOddor", bp::no_init );
        bp::scope LogOddor_scope( LogOddor_exposer );
        { //::alignlib::LogOddor::fillProfile
        
            typedef void ( ::alignlib::LogOddor::*fillProfile_function_type )( ::alignlib::ScoreMatrix &,::alignlib::FrequencyMatrix const & ) const;
            
            LogOddor_exposer.def( 
                "fillProfile"
                , fillProfile_function_type( &::alignlib::LogOddor::fillProfile )
                , ( bp::arg("scores"), bp::arg("frequencies") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::LogOddor > >();
    }

    { //::alignlib::Matrix<double>
        typedef bp::class_< alignlib::Matrix<double> > MatrixDouble_exposer_t;
        MatrixDouble_exposer_t MatrixDouble_exposer = MatrixDouble_exposer_t( "MatrixDouble", bp::init< unsigned int, unsigned int, bp::optional< alignlib::Score > >(( bp::arg("r"), bp::arg("c"), bp::arg("default_value")=0 )) );
        bp::scope MatrixDouble_scope( MatrixDouble_exposer );
        MatrixDouble_exposer.def( bp::init< alignlib::Matrix<double> const & >(( bp::arg("src") )) );
        { //::alignlib::Matrix<double>::getNumCols
        
            typedef alignlib::Matrix<double> exported_class_t;
            typedef unsigned int ( exported_class_t::*getNumCols_function_type )(  ) const;
            
            MatrixDouble_exposer.def( 
                "getNumCols"
                , getNumCols_function_type( &::alignlib::Matrix<double>::getNumCols ) );
        
        }
        { //::alignlib::Matrix<double>::getNumRows
        
            typedef alignlib::Matrix<double> exported_class_t;
            typedef unsigned int ( exported_class_t::*getNumRows_function_type )(  ) const;
            
            MatrixDouble_exposer.def( 
                "getNumRows"
                , getNumRows_function_type( &::alignlib::Matrix<double>::getNumRows ) );
        
        }
        { //::alignlib::Matrix<double>::getValue
        
            typedef alignlib::Matrix<double> exported_class_t;
            typedef ::alignlib::Score ( exported_class_t::*getValue_function_type )( unsigned int,unsigned int ) const;
            
            MatrixDouble_exposer.def( 
                "getValue"
                , getValue_function_type( &::alignlib::Matrix<double>::getValue )
                , ( bp::arg("row"), bp::arg("col") ) );
        
        }
        { //::alignlib::Matrix<double>::operator=
        
            typedef alignlib::Matrix<double> exported_class_t;
            typedef ::alignlib::Matrix<double> & ( exported_class_t::*assign_function_type )( ::alignlib::Matrix<double> const & ) ;
            
            MatrixDouble_exposer.def( 
                "assign"
                , assign_function_type( &::alignlib::Matrix<double>::operator= )
                , ( bp::arg("src") )
                , bp::return_self< >() );
        
        }
        MatrixDouble_exposer.def( bp::self == bp::self );
        { //::alignlib::Matrix<double>::permuteCols
        
            typedef alignlib::Matrix<double> exported_class_t;
            typedef void ( exported_class_t::*permuteCols_function_type )( ::std::vector<unsigned int,std::allocator<unsigned int> > & ) ;
            
            MatrixDouble_exposer.def( 
                "permuteCols"
                , permuteCols_function_type( &::alignlib::Matrix<double>::permuteCols )
                , ( bp::arg("map_new2old") ) );
        
        }
        { //::alignlib::Matrix<double>::permuteRows
        
            typedef alignlib::Matrix<double> exported_class_t;
            typedef void ( exported_class_t::*permuteRows_function_type )( ::std::vector<unsigned int,std::allocator<unsigned int> > & ) ;
            
            MatrixDouble_exposer.def( 
                "permuteRows"
                , permuteRows_function_type( &::alignlib::Matrix<double>::permuteRows )
                , ( bp::arg("map_new2old") ) );
        
        }
        { //::alignlib::Matrix<double>::setValue
        
            typedef alignlib::Matrix<double> exported_class_t;
            typedef void ( exported_class_t::*setValue_function_type )( unsigned int,unsigned int,::alignlib::Score const & ) ;
            
            MatrixDouble_exposer.def( 
                "setValue"
                , setValue_function_type( &::alignlib::Matrix<double>::setValue )
                , ( bp::arg("row"), bp::arg("col"), bp::arg("value") ) );
        
        }
        { //::alignlib::Matrix<double>::swapRows
        
            typedef alignlib::Matrix<double> exported_class_t;
            typedef void ( exported_class_t::*swapRows_function_type )( unsigned int,unsigned int ) ;
            
            MatrixDouble_exposer.def( 
                "swapRows"
                , swapRows_function_type( &::alignlib::Matrix<double>::swapRows )
                , ( bp::arg("x"), bp::arg("y") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Matrix<double> > >();
    }

    { //::alignlib::Matrix<int>
        typedef bp::class_< alignlib::Matrix<int> > MatrixInt_exposer_t;
        MatrixInt_exposer_t MatrixInt_exposer = MatrixInt_exposer_t( "MatrixInt", bp::init< unsigned int, unsigned int, bp::optional< int > >(( bp::arg("r"), bp::arg("c"), bp::arg("default_value")=(int)(0) )) );
        bp::scope MatrixInt_scope( MatrixInt_exposer );
        MatrixInt_exposer.def( bp::init< alignlib::Matrix<int> const & >(( bp::arg("src") )) );
        { //::alignlib::Matrix<int>::getNumCols
        
            typedef alignlib::Matrix<int> exported_class_t;
            typedef unsigned int ( exported_class_t::*getNumCols_function_type )(  ) const;
            
            MatrixInt_exposer.def( 
                "getNumCols"
                , getNumCols_function_type( &::alignlib::Matrix<int>::getNumCols ) );
        
        }
        { //::alignlib::Matrix<int>::getNumRows
        
            typedef alignlib::Matrix<int> exported_class_t;
            typedef unsigned int ( exported_class_t::*getNumRows_function_type )(  ) const;
            
            MatrixInt_exposer.def( 
                "getNumRows"
                , getNumRows_function_type( &::alignlib::Matrix<int>::getNumRows ) );
        
        }
        { //::alignlib::Matrix<int>::getValue
        
            typedef alignlib::Matrix<int> exported_class_t;
            typedef int ( exported_class_t::*getValue_function_type )( unsigned int,unsigned int ) const;
            
            MatrixInt_exposer.def( 
                "getValue"
                , getValue_function_type( &::alignlib::Matrix<int>::getValue )
                , ( bp::arg("row"), bp::arg("col") ) );
        
        }
        { //::alignlib::Matrix<int>::operator=
        
            typedef alignlib::Matrix<int> exported_class_t;
            typedef ::alignlib::Matrix<int> & ( exported_class_t::*assign_function_type )( ::alignlib::Matrix<int> const & ) ;
            
            MatrixInt_exposer.def( 
                "assign"
                , assign_function_type( &::alignlib::Matrix<int>::operator= )
                , ( bp::arg("src") )
                , bp::return_self< >() );
        
        }
        MatrixInt_exposer.def( bp::self == bp::self );
        { //::alignlib::Matrix<int>::permuteCols
        
            typedef alignlib::Matrix<int> exported_class_t;
            typedef void ( exported_class_t::*permuteCols_function_type )( ::std::vector<unsigned int,std::allocator<unsigned int> > & ) ;
            
            MatrixInt_exposer.def( 
                "permuteCols"
                , permuteCols_function_type( &::alignlib::Matrix<int>::permuteCols )
                , ( bp::arg("map_new2old") ) );
        
        }
        { //::alignlib::Matrix<int>::permuteRows
        
            typedef alignlib::Matrix<int> exported_class_t;
            typedef void ( exported_class_t::*permuteRows_function_type )( ::std::vector<unsigned int,std::allocator<unsigned int> > & ) ;
            
            MatrixInt_exposer.def( 
                "permuteRows"
                , permuteRows_function_type( &::alignlib::Matrix<int>::permuteRows )
                , ( bp::arg("map_new2old") ) );
        
        }
        { //::alignlib::Matrix<int>::setValue
        
            typedef alignlib::Matrix<int> exported_class_t;
            typedef void ( exported_class_t::*setValue_function_type )( unsigned int,unsigned int,int const & ) ;
            
            MatrixInt_exposer.def( 
                "setValue"
                , setValue_function_type( &::alignlib::Matrix<int>::setValue )
                , ( bp::arg("row"), bp::arg("col"), bp::arg("value") ) );
        
        }
        { //::alignlib::Matrix<int>::swapRows
        
            typedef alignlib::Matrix<int> exported_class_t;
            typedef void ( exported_class_t::*swapRows_function_type )( unsigned int,unsigned int ) ;
            
            MatrixInt_exposer.def( 
                "swapRows"
                , swapRows_function_type( &::alignlib::Matrix<int>::swapRows )
                , ( bp::arg("x"), bp::arg("y") ) );
        
        }
    }

    { //::alignlib::Matrix<unsigned>
        typedef bp::class_< alignlib::Matrix<unsigned> > MatrixUInt_exposer_t;
        MatrixUInt_exposer_t MatrixUInt_exposer = MatrixUInt_exposer_t( "MatrixUInt", bp::init< unsigned int, unsigned int, bp::optional< unsigned int > >(( bp::arg("r"), bp::arg("c"), bp::arg("default_value")=(unsigned int)(0) )) );
        bp::scope MatrixUInt_scope( MatrixUInt_exposer );
        MatrixUInt_exposer.def( bp::init< alignlib::Matrix<unsigned> const & >(( bp::arg("src") )) );
        { //::alignlib::Matrix<unsigned>::getNumCols
        
            typedef alignlib::Matrix<unsigned> exported_class_t;
            typedef unsigned int ( exported_class_t::*getNumCols_function_type )(  ) const;
            
            MatrixUInt_exposer.def( 
                "getNumCols"
                , getNumCols_function_type( &::alignlib::Matrix<unsigned>::getNumCols ) );
        
        }
        { //::alignlib::Matrix<unsigned>::getNumRows
        
            typedef alignlib::Matrix<unsigned> exported_class_t;
            typedef unsigned int ( exported_class_t::*getNumRows_function_type )(  ) const;
            
            MatrixUInt_exposer.def( 
                "getNumRows"
                , getNumRows_function_type( &::alignlib::Matrix<unsigned>::getNumRows ) );
        
        }
        { //::alignlib::Matrix<unsigned>::getValue
        
            typedef alignlib::Matrix<unsigned> exported_class_t;
            typedef unsigned int ( exported_class_t::*getValue_function_type )( unsigned int,unsigned int ) const;
            
            MatrixUInt_exposer.def( 
                "getValue"
                , getValue_function_type( &::alignlib::Matrix<unsigned>::getValue )
                , ( bp::arg("row"), bp::arg("col") ) );
        
        }
        { //::alignlib::Matrix<unsigned>::operator=
        
            typedef alignlib::Matrix<unsigned> exported_class_t;
            typedef ::alignlib::Matrix<unsigned> & ( exported_class_t::*assign_function_type )( ::alignlib::Matrix<unsigned> const & ) ;
            
            MatrixUInt_exposer.def( 
                "assign"
                , assign_function_type( &::alignlib::Matrix<unsigned>::operator= )
                , ( bp::arg("src") )
                , bp::return_self< >() );
        
        }
        MatrixUInt_exposer.def( bp::self == bp::self );
        { //::alignlib::Matrix<unsigned>::permuteCols
        
            typedef alignlib::Matrix<unsigned> exported_class_t;
            typedef void ( exported_class_t::*permuteCols_function_type )( ::std::vector<unsigned int,std::allocator<unsigned int> > & ) ;
            
            MatrixUInt_exposer.def( 
                "permuteCols"
                , permuteCols_function_type( &::alignlib::Matrix<unsigned>::permuteCols )
                , ( bp::arg("map_new2old") ) );
        
        }
        { //::alignlib::Matrix<unsigned>::permuteRows
        
            typedef alignlib::Matrix<unsigned> exported_class_t;
            typedef void ( exported_class_t::*permuteRows_function_type )( ::std::vector<unsigned int,std::allocator<unsigned int> > & ) ;
            
            MatrixUInt_exposer.def( 
                "permuteRows"
                , permuteRows_function_type( &::alignlib::Matrix<unsigned>::permuteRows )
                , ( bp::arg("map_new2old") ) );
        
        }
        { //::alignlib::Matrix<unsigned>::setValue
        
            typedef alignlib::Matrix<unsigned> exported_class_t;
            typedef void ( exported_class_t::*setValue_function_type )( unsigned int,unsigned int,unsigned int const & ) ;
            
            MatrixUInt_exposer.def( 
                "setValue"
                , setValue_function_type( &::alignlib::Matrix<unsigned>::setValue )
                , ( bp::arg("row"), bp::arg("col"), bp::arg("value") ) );
        
        }
        { //::alignlib::Matrix<unsigned>::swapRows
        
            typedef alignlib::Matrix<unsigned> exported_class_t;
            typedef void ( exported_class_t::*swapRows_function_type )( unsigned int,unsigned int ) ;
            
            MatrixUInt_exposer.def( 
                "swapRows"
                , swapRows_function_type( &::alignlib::Matrix<unsigned>::swapRows )
                , ( bp::arg("x"), bp::arg("y") ) );
        
        }
    }

    { //::alignlib::MultipleAlignment
        typedef bp::class_< alignlib::MultipleAlignment, boost::noncopyable > MultipleAlignment_exposer_t;
        MultipleAlignment_exposer_t MultipleAlignment_exposer = MultipleAlignment_exposer_t( "MultipleAlignment", bp::no_init );
        bp::scope MultipleAlignment_scope( MultipleAlignment_exposer );
        { //::alignlib::MultipleAlignment::add
        
            typedef void ( ::alignlib::MultipleAlignment::*add_function_type )( ::alignlib::HAlignatum const &,::alignlib::HAlignment const &,bool,bool,bool,bool,bool ) ;
            
            MultipleAlignment_exposer.def( 
                "add"
                , add_function_type( &::alignlib::MultipleAlignment::add )
                , ( bp::arg("src"), bp::arg("alignment"), bp::arg("mali_is_in_row")=(bool)(true), bp::arg("insert_gaps_mali")=(bool)(true), bp::arg("insert_gaps_alignatum")=(bool)(true), bp::arg("use_end_mali")=(bool)(false), bp::arg("use_end_alignatum")=(bool)(false) ) );
        
        }
        { //::alignlib::MultipleAlignment::add
        
            typedef void ( ::alignlib::MultipleAlignment::*add_function_type )( ::alignlib::HAlignatum const & ) ;
            
            MultipleAlignment_exposer.def( 
                "add"
                , add_function_type( &::alignlib::MultipleAlignment::add )
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::MultipleAlignment::add
        
            typedef void ( ::alignlib::MultipleAlignment::*add_function_type )( ::alignlib::HMultipleAlignment const &,::alignlib::HAlignment const &,bool,bool,bool,bool,bool ) ;
            
            MultipleAlignment_exposer.def( 
                "add"
                , add_function_type( &::alignlib::MultipleAlignment::add )
                , ( bp::arg("src"), bp::arg("alignment"), bp::arg("mali_is_in_row")=(bool)(true), bp::arg("insert_gaps_mali")=(bool)(true), bp::arg("insert_gaps_alignatum")=(bool)(true), bp::arg("use_end_mali")=(bool)(false), bp::arg("use_end_alignatum")=(bool)(false) ) );
        
        }
        { //::alignlib::MultipleAlignment::add
        
            typedef void ( ::alignlib::MultipleAlignment::*add_function_type )( ::alignlib::HMultipleAlignment const & ) ;
            
            MultipleAlignment_exposer.def( 
                "add"
                , add_function_type( &::alignlib::MultipleAlignment::add )
                , ( bp::arg("src") ) );
        
        }
        { //::alignlib::MultipleAlignment::clear
        
            typedef void ( ::alignlib::MultipleAlignment::*clear_function_type )(  ) ;
            
            MultipleAlignment_exposer.def( 
                "clear"
                , clear_function_type( &::alignlib::MultipleAlignment::clear ) );
        
        }
        { //::alignlib::MultipleAlignment::eraseRow
        
            typedef void ( ::alignlib::MultipleAlignment::*eraseRow_function_type )( int ) ;
            
            MultipleAlignment_exposer.def( 
                "eraseRow"
                , eraseRow_function_type( &::alignlib::MultipleAlignment::eraseRow )
                , ( bp::arg("row") ) );
        
        }
        { //::alignlib::MultipleAlignment::getClone
        
            typedef ::alignlib::HMultipleAlignment ( ::alignlib::MultipleAlignment::*getClone_function_type )(  ) const;
            
            MultipleAlignment_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::MultipleAlignment::getClone ) );
        
        }
        { //::alignlib::MultipleAlignment::getLength
        
            typedef ::alignlib::Position ( ::alignlib::MultipleAlignment::*getLength_function_type )(  ) const;
            
            MultipleAlignment_exposer.def( 
                "getLength"
                , getLength_function_type( &::alignlib::MultipleAlignment::getLength ) );
        
        }
        { //::alignlib::MultipleAlignment::getNew
        
            typedef ::alignlib::HMultipleAlignment ( ::alignlib::MultipleAlignment::*getNew_function_type )(  ) const;
            
            MultipleAlignment_exposer.def( 
                "getNew"
                , getNew_function_type( &::alignlib::MultipleAlignment::getNew ) );
        
        }
        { //::alignlib::MultipleAlignment::getNumSequences
        
            typedef int ( ::alignlib::MultipleAlignment::*getNumSequences_function_type )(  ) const;
            
            MultipleAlignment_exposer.def( 
                "getNumSequences"
                , getNumSequences_function_type( &::alignlib::MultipleAlignment::getNumSequences ) );
        
        }
        { //::alignlib::MultipleAlignment::getRow
        
            typedef ::alignlib::HAlignatum ( ::alignlib::MultipleAlignment::*getRow_function_type )( int ) const;
            
            MultipleAlignment_exposer.def( 
                "getRow"
                , getRow_function_type( &::alignlib::MultipleAlignment::getRow )
                , ( bp::arg("row") ) );
        
        }
        { //::alignlib::MultipleAlignment::isEmpty
        
            typedef bool ( ::alignlib::MultipleAlignment::*isEmpty_function_type )(  ) const;
            
            MultipleAlignment_exposer.def( 
                "isEmpty"
                , isEmpty_function_type( &::alignlib::MultipleAlignment::isEmpty ) );
        
        }
        { //::alignlib::MultipleAlignment::registerRenderer
        
            typedef void ( ::alignlib::MultipleAlignment::*registerRenderer_function_type )( ::alignlib::HRenderer const & ) ;
            
            MultipleAlignment_exposer.def( 
                "registerRenderer"
                , registerRenderer_function_type( &::alignlib::MultipleAlignment::registerRenderer )
                , ( bp::arg("renderer") ) );
        
        }
        { //::alignlib::MultipleAlignment::setLength
        
            typedef void ( ::alignlib::MultipleAlignment::*setLength_function_type )( ::alignlib::Position ) ;
            
            MultipleAlignment_exposer.def( 
                "setLength"
                , setLength_function_type( &::alignlib::MultipleAlignment::setLength )
                , ( bp::arg("length") ) );
        
        }
        { //::alignlib::MultipleAlignment::write
        
            typedef void ( ::alignlib::MultipleAlignment::*write_function_type )( ::std::ostream & ) const;
            
            MultipleAlignment_exposer.def( 
                "write"
                , write_function_type( &::alignlib::MultipleAlignment::write )
                , ( bp::arg("output") ) );
        
        }
        MultipleAlignment_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::MultipleAlignment > >();
    }

    { //::alignlib::NormalDistributionParameters
        typedef bp::class_< alignlib::NormalDistributionParameters > NormalDistributionParameters_exposer_t;
        NormalDistributionParameters_exposer_t NormalDistributionParameters_exposer = NormalDistributionParameters_exposer_t( "NormalDistributionParameters" );
        bp::scope NormalDistributionParameters_scope( NormalDistributionParameters_exposer );
        { //::alignlib::NormalDistributionParameters::getMean
        
            typedef double ( ::alignlib::NormalDistributionParameters::*getMean_function_type )(  ) ;
            
            NormalDistributionParameters_exposer.def( 
                "getMean"
                , getMean_function_type( &::alignlib::NormalDistributionParameters::getMean ) );
        
        }
        { //::alignlib::NormalDistributionParameters::getStandardDeviation
        
            typedef double ( ::alignlib::NormalDistributionParameters::*getStandardDeviation_function_type )(  ) ;
            
            NormalDistributionParameters_exposer.def( 
                "getStandardDeviation"
                , getStandardDeviation_function_type( &::alignlib::NormalDistributionParameters::getStandardDeviation ) );
        
        }
        NormalDistributionParameters_exposer.def_readwrite( "mMean", &alignlib::NormalDistributionParameters::mMean );
        NormalDistributionParameters_exposer.def_readwrite( "mStandardDeviation", &alignlib::NormalDistributionParameters::mStandardDeviation );
    }

    { //::alignlib::Regularizor
        typedef bp::class_< alignlib::Regularizor, boost::noncopyable > Regularizor_exposer_t;
        Regularizor_exposer_t Regularizor_exposer = Regularizor_exposer_t( "Regularizor", bp::no_init );
        bp::scope Regularizor_scope( Regularizor_exposer );
        { //::alignlib::Regularizor::fillFrequencies
        
            typedef void ( ::alignlib::Regularizor::*fillFrequencies_function_type )( ::alignlib::FrequencyMatrix &,::alignlib::CountMatrix const & ) const;
            
            Regularizor_exposer.def( 
                "fillFrequencies"
                , fillFrequencies_function_type( &::alignlib::Regularizor::fillFrequencies )
                , ( bp::arg("frequencies"), bp::arg("counts") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Regularizor > >();
    }

    { //::alignlib::Renderer
        typedef bp::class_< alignlib::Renderer, boost::noncopyable > Renderer_exposer_t;
        Renderer_exposer_t Renderer_exposer = Renderer_exposer_t( "Renderer", bp::no_init );
        bp::scope Renderer_scope( Renderer_exposer );
        { //::alignlib::Renderer::render
        
            typedef ::std::string ( ::alignlib::Renderer::*render_function_type )( ::std::string const &,::alignlib::Position,::alignlib::Position ) const;
            
            Renderer_exposer.def( 
                "render"
                , render_function_type( &::alignlib::Renderer::render )
                , ( bp::arg("representation"), bp::arg("segment_start"), bp::arg("segment_end") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Renderer > >();
    }

    { //::alignlib::ResiduePair
        typedef bp::class_< alignlib::ResiduePair > ResiduePair_exposer_t;
        ResiduePair_exposer_t ResiduePair_exposer = ResiduePair_exposer_t( "ResiduePair" );
        bp::scope ResiduePair_scope( ResiduePair_exposer );
        { //::alignlib::ResiduePair::getDiagonal
        
            typedef ::alignlib::Position ( ::alignlib::ResiduePair::*getDiagonal_function_type )(  ) const;
            
            ResiduePair_exposer.def( 
                "getDiagonal"
                , getDiagonal_function_type( &::alignlib::ResiduePair::getDiagonal ) );
        
        }
        { //::alignlib::ResiduePair::operator=
        
            typedef ::alignlib::ResiduePair & ( ::alignlib::ResiduePair::*assign_function_type )( ::alignlib::ResiduePair const & ) ;
            
            ResiduePair_exposer.def( 
                "assign"
                , assign_function_type( &::alignlib::ResiduePair::operator= )
                , ( bp::arg("src") )
                , bp::return_self< >() );
        
        }
        ResiduePair_exposer.def_readwrite( "mCol", &alignlib::ResiduePair::mCol );
        ResiduePair_exposer.def_readwrite( "mRow", &alignlib::ResiduePair::mRow );
        ResiduePair_exposer.def_readwrite( "mScore", &alignlib::ResiduePair::mScore );
        ResiduePair_exposer.def( bp::self_ns::str( bp::self ) );
    }

    { //::alignlib::Scorer
        typedef bp::class_< alignlib::Scorer, boost::noncopyable > Scorer_exposer_t;
        Scorer_exposer_t Scorer_exposer = Scorer_exposer_t( "Scorer", bp::no_init );
        bp::scope Scorer_scope( Scorer_exposer );
        { //::alignlib::Scorer::getClone
        
            typedef ::alignlib::HScorer ( ::alignlib::Scorer::*getClone_function_type )(  ) const;
            
            Scorer_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::Scorer::getClone ) );
        
        }
        { //::alignlib::Scorer::getNew
        
            typedef ::alignlib::HScorer ( ::alignlib::Scorer::*getNew_function_type )( ::alignlib::HAlignandum const &,::alignlib::HAlignandum const & ) const;
            
            Scorer_exposer.def( 
                "getNew"
                , getNew_function_type( &::alignlib::Scorer::getNew )
                , ( bp::arg("row"), bp::arg("col") ) );
        
        }
        { //::alignlib::Scorer::getScore
        
            typedef ::alignlib::Score ( ::alignlib::Scorer::*getScore_function_type )( ::alignlib::Position,::alignlib::Position ) const;
            
            Scorer_exposer.def( 
                "getScore"
                , getScore_function_type( &::alignlib::Scorer::getScore )
                , ( bp::arg("row"), bp::arg("col") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Scorer > >();
    }

    { //::alignlib::Tree
        typedef bp::class_< alignlib::Tree, boost::noncopyable > Tree_exposer_t;
        Tree_exposer_t Tree_exposer = Tree_exposer_t( "Tree", bp::no_init );
        bp::scope Tree_scope( Tree_exposer );
        { //::alignlib::Tree::findLastParent
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*findLastParent_function_type )( ::alignlib::Node const ) const;
            
            Tree_exposer.def( 
                "findLastParent"
                , findLastParent_function_type( &::alignlib::Tree::findLastParent )
                , ( bp::arg("node") ) );
        
        }
        { //::alignlib::Tree::getClone
        
            typedef ::alignlib::HTree ( ::alignlib::Tree::*getClone_function_type )(  ) const;
            
            Tree_exposer.def( 
                "getClone"
                , getClone_function_type( &::alignlib::Tree::getClone ) );
        
        }
        { //::alignlib::Tree::getHeight
        
            typedef ::alignlib::TreeHeight ( ::alignlib::Tree::*getHeight_function_type )( ::alignlib::Node ) const;
            
            Tree_exposer.def( 
                "getHeight"
                , getHeight_function_type( &::alignlib::Tree::getHeight )
                , ( bp::arg("node") ) );
        
        }
        { //::alignlib::Tree::getLeftChild
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*getLeftChild_function_type )( ::alignlib::Node ) const;
            
            Tree_exposer.def( 
                "getLeftChild"
                , getLeftChild_function_type( &::alignlib::Tree::getLeftChild )
                , ( bp::arg("node") ) );
        
        }
        { //::alignlib::Tree::getNew
        
            typedef ::alignlib::HTree ( ::alignlib::Tree::*getNew_function_type )(  ) const;
            
            Tree_exposer.def( 
                "getNew"
                , getNew_function_type( &::alignlib::Tree::getNew ) );
        
        }
        { //::alignlib::Tree::getNoNode
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*getNoNode_function_type )(  ) const;
            
            Tree_exposer.def( 
                "getNoNode"
                , getNoNode_function_type( &::alignlib::Tree::getNoNode ) );
        
        }
        { //::alignlib::Tree::getNodesBreadthFirstVisit
        
            typedef ::alignlib::HNodeVector ( ::alignlib::Tree::*getNodesBreadthFirstVisit_function_type )(  ) const;
            
            Tree_exposer.def( 
                "getNodesBreadthFirstVisit"
                , getNodesBreadthFirstVisit_function_type( &::alignlib::Tree::getNodesBreadthFirstVisit ) );
        
        }
        { //::alignlib::Tree::getNodesDepthFirstFinish
        
            typedef ::alignlib::HNodeVector ( ::alignlib::Tree::*getNodesDepthFirstFinish_function_type )(  ) const;
            
            Tree_exposer.def( 
                "getNodesDepthFirstFinish"
                , getNodesDepthFirstFinish_function_type( &::alignlib::Tree::getNodesDepthFirstFinish ) );
        
        }
        { //::alignlib::Tree::getNodesDepthFirstVisit
        
            typedef ::alignlib::HNodeVector ( ::alignlib::Tree::*getNodesDepthFirstVisit_function_type )(  ) const;
            
            Tree_exposer.def( 
                "getNodesDepthFirstVisit"
                , getNodesDepthFirstVisit_function_type( &::alignlib::Tree::getNodesDepthFirstVisit ) );
        
        }
        { //::alignlib::Tree::getNodesLeaves
        
            typedef ::alignlib::HNodeVector ( ::alignlib::Tree::*getNodesLeaves_function_type )(  ) const;
            
            Tree_exposer.def( 
                "getNodesLeaves"
                , getNodesLeaves_function_type( &::alignlib::Tree::getNodesLeaves ) );
        
        }
        { //::alignlib::Tree::getNumLeaves
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*getNumLeaves_function_type )(  ) const;
            
            Tree_exposer.def( 
                "getNumLeaves"
                , getNumLeaves_function_type( &::alignlib::Tree::getNumLeaves ) );
        
        }
        { //::alignlib::Tree::getNumLeaves
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*getNumLeaves_function_type )( ::alignlib::Node ) const;
            
            Tree_exposer.def( 
                "getNumLeaves"
                , getNumLeaves_function_type( &::alignlib::Tree::getNumLeaves )
                , ( bp::arg("node") ) );
        
        }
        { //::alignlib::Tree::getParent
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*getParent_function_type )( ::alignlib::Node ) const;
            
            Tree_exposer.def( 
                "getParent"
                , getParent_function_type( &::alignlib::Tree::getParent )
                , ( bp::arg("node") ) );
        
        }
        { //::alignlib::Tree::getRightChild
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*getRightChild_function_type )( ::alignlib::Node ) const;
            
            Tree_exposer.def( 
                "getRightChild"
                , getRightChild_function_type( &::alignlib::Tree::getRightChild )
                , ( bp::arg("node") ) );
        
        }
        { //::alignlib::Tree::getRoot
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*getRoot_function_type )(  ) const;
            
            Tree_exposer.def( 
                "getRoot"
                , getRoot_function_type( &::alignlib::Tree::getRoot ) );
        
        }
        { //::alignlib::Tree::getWeight
        
            typedef ::alignlib::TreeWeight ( ::alignlib::Tree::*getWeight_function_type )( ::alignlib::Node,::alignlib::Node ) const;
            
            Tree_exposer.def( 
                "getWeight"
                , getWeight_function_type( &::alignlib::Tree::getWeight )
                , ( bp::arg("child"), bp::arg("parent") ) );
        
        }
        { //::alignlib::Tree::joinNodes
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*joinNodes_function_type )( ::alignlib::Node const,::alignlib::Node const,::alignlib::TreeWeight const,::alignlib::TreeWeight const ) ;
            
            Tree_exposer.def( 
                "joinNodes"
                , joinNodes_function_type( &::alignlib::Tree::joinNodes )
                , ( bp::arg("node_1"), bp::arg("node_2"), bp::arg("weight_1"), bp::arg("weight_2") ) );
        
        }
        { //::alignlib::Tree::removeRoot
        
            typedef void ( ::alignlib::Tree::*removeRoot_function_type )(  ) ;
            
            Tree_exposer.def( 
                "removeRoot"
                , removeRoot_function_type( &::alignlib::Tree::removeRoot ) );
        
        }
        { //::alignlib::Tree::setHeight
        
            typedef void ( ::alignlib::Tree::*setHeight_function_type )( ::alignlib::Node,::alignlib::TreeHeight ) ;
            
            Tree_exposer.def( 
                "setHeight"
                , setHeight_function_type( &::alignlib::Tree::setHeight )
                , ( bp::arg("node"), bp::arg("height") ) );
        
        }
        { //::alignlib::Tree::setNumLeaves
        
            typedef void ( ::alignlib::Tree::*setNumLeaves_function_type )( unsigned int ) ;
            
            Tree_exposer.def( 
                "setNumLeaves"
                , setNumLeaves_function_type( &::alignlib::Tree::setNumLeaves )
                , ( bp::arg("num_leaves") ) );
        
        }
        { //::alignlib::Tree::setRoot
        
            typedef ::alignlib::Node ( ::alignlib::Tree::*setRoot_function_type )( ::alignlib::Node const,::alignlib::Node const,::alignlib::TreeWeight ) ;
            
            Tree_exposer.def( 
                "setRoot"
                , setRoot_function_type( &::alignlib::Tree::setRoot )
                , ( bp::arg("node_1"), bp::arg("node_2"), bp::arg("weight") ) );
        
        }
        { //::alignlib::Tree::setWeight
        
            typedef void ( ::alignlib::Tree::*setWeight_function_type )( ::alignlib::Node,::alignlib::Node,::alignlib::TreeWeight ) ;
            
            Tree_exposer.def( 
                "setWeight"
                , setWeight_function_type( &::alignlib::Tree::setWeight )
                , ( bp::arg("child"), bp::arg("parent"), bp::arg("weight") ) );
        
        }
        { //::alignlib::Tree::write
        
            typedef void ( ::alignlib::Tree::*write_function_type )( ::std::ostream & ) const;
            
            Tree_exposer.def( 
                "write"
                , write_function_type( &::alignlib::Tree::write )
                , ( bp::arg("output") ) );
        
        }
        Tree_exposer.def( bp::self_ns::str( bp::self ) );
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Tree > >();
    }

    { //::alignlib::Treetor
        typedef bp::class_< alignlib::Treetor, boost::noncopyable > Treetor_exposer_t;
        Treetor_exposer_t Treetor_exposer = Treetor_exposer_t( "Treetor", bp::no_init );
        bp::scope Treetor_scope( Treetor_exposer );
        { //::alignlib::Treetor::calculateTree
        
            typedef void ( ::alignlib::Treetor::*calculateTree_function_type )( ::alignlib::HTree &,::alignlib::HMultipleAlignment const & ) const;
            
            Treetor_exposer.def( 
                "calculateTree"
                , calculateTree_function_type( &::alignlib::Treetor::calculateTree )
                , ( bp::arg("dest"), bp::arg("src") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Treetor > >();
    }

    { //::alignlib::Weightor
        typedef bp::class_< alignlib::Weightor, boost::noncopyable > Weightor_exposer_t;
        Weightor_exposer_t Weightor_exposer = Weightor_exposer_t( "Weightor", bp::no_init );
        bp::scope Weightor_scope( Weightor_exposer );
        { //::alignlib::Weightor::fillCounts
        
            typedef void ( ::alignlib::Weightor::*fillCounts_function_type )( ::alignlib::CountMatrix &,::alignlib::HMultipleAlignment const &,::alignlib::HEncoder const & ) const;
            
            Weightor_exposer.def( 
                "fillCounts"
                , fillCounts_function_type( &::alignlib::Weightor::fillCounts )
                , ( bp::arg("counts"), bp::arg("src"), bp::arg("translator") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< alignlib::Weightor > >();
    }

    { //::alignlib::addAlignment2Alignment
    
        typedef void ( *addAlignment2Alignment_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const & );
        
        bp::def( 
            "addAlignment2Alignment"
            , addAlignment2Alignment_function_type( &::alignlib::addAlignment2Alignment )
            , ( bp::arg("dest"), bp::arg("src") ) );
    
    }

    { //::alignlib::addDiagonal2Alignment
    
        typedef void ( *addDiagonal2Alignment_function_type )( ::alignlib::HAlignment &,::alignlib::Position,::alignlib::Position,::alignlib::Position );
        
        bp::def( 
            "addDiagonal2Alignment"
            , addDiagonal2Alignment_function_type( &::alignlib::addDiagonal2Alignment )
            , ( bp::arg("dest"), bp::arg("row_from"), bp::arg("row_to"), bp::arg("col_offset")=(int)(0) ) );
    
    }

    { //::alignlib::addMappedAlignment2Alignment
    
        typedef void ( *addMappedAlignment2Alignment_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const &,::alignlib::HAlignment const &,::alignlib::CombinationMode const );
        
        bp::def( 
            "addMappedAlignment2Alignment"
            , addMappedAlignment2Alignment_function_type( &::alignlib::addMappedAlignment2Alignment )
            , ( bp::arg("dest"), bp::arg("src"), bp::arg("map_src2new"), bp::arg("mode") ) );
    
    }

    { //::alignlib::addMappedAlignments2Alignment
    
        typedef void ( *addMappedAlignments2Alignment_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const &,::alignlib::HAlignment const &,::alignlib::HAlignment const & );
        
        bp::def( 
            "addMappedAlignments2Alignment"
            , addMappedAlignments2Alignment_function_type( &::alignlib::addMappedAlignments2Alignment )
            , ( bp::arg("dest"), bp::arg("src"), bp::arg("map_src_row2dest_row"), bp::arg("map_src_col2dest_col") ) );
    
    }

    { //::alignlib::calculateAffineScore
    
        typedef void ( *calculateAffineScore_function_type )( ::alignlib::HAlignment &,::alignlib::Score const,::alignlib::Score const );
        
        bp::def( 
            "calculateAffineScore"
            , calculateAffineScore_function_type( &::alignlib::calculateAffineScore )
            , ( bp::arg("dest"), bp::arg("gop"), bp::arg("gep") ) );
    
    }

    { //::alignlib::calculatePercentIdentity
    
        typedef double ( *calculatePercentIdentity_function_type )( ::alignlib::HAlignment const &,::alignlib::HAlignandum const &,::alignlib::HAlignandum const & );
        
        bp::def( 
            "calculatePercentIdentity"
            , calculatePercentIdentity_function_type( &::alignlib::calculatePercentIdentity )
            , ( bp::arg("src"), bp::arg("row"), bp::arg("col") ) );
    
    }

    { //::alignlib::calculatePercentSimilarity
    
        typedef double ( *calculatePercentSimilarity_function_type )( ::alignlib::HAlignment const & );
        
        bp::def( 
            "calculatePercentSimilarity"
            , calculatePercentSimilarity_function_type( &::alignlib::calculatePercentSimilarity )
            , ( bp::arg("src") ) );
    
    }

    { //::alignlib::calculateZScore
    
        typedef ::alignlib::Score ( *calculateZScore_function_type )( ::alignlib::Score,::alignlib::NormalDistributionParameters const * );
        
        bp::def( 
            "calculateZScore"
            , calculateZScore_function_type( &::alignlib::calculateZScore )
            , ( bp::arg("score"), bp::arg("params") ) );
    
    }

    { //::alignlib::calculateZScoreParameters
    
        typedef void ( *calculateZScoreParameters_function_type )( ::alignlib::NormalDistributionParameters *,::alignlib::HAlignandum const &,::alignlib::HAlignandum const &,::alignlib::HAlignator const &,unsigned int,unsigned int,::alignlib::Position );
        
        bp::def( 
            "calculateZScoreParameters"
            , calculateZScoreParameters_function_type( &::alignlib::calculateZScoreParameters )
            , ( bp::arg("result"), bp::arg("row"), bp::arg("col"), bp::arg("alignator"), bp::arg("n_iterations"), bp::arg("n_iterations_shuffle")=(unsigned int)(1), bp::arg("window_size")=(int)(0) ) );
    
    }

    { //::alignlib::checkAlignmentIdentity
    
        typedef bool ( *checkAlignmentIdentity_function_type )( ::alignlib::HAlignment const &,::alignlib::HAlignment const &,bool const );
        
        bp::def( 
            "checkAlignmentIdentity"
            , checkAlignmentIdentity_function_type( &::alignlib::checkAlignmentIdentity )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("invert")=(bool const)(false) ) );
    
    }

    { //::alignlib::combineAlignment
    
        typedef void ( *combineAlignment_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const &,::alignlib::HAlignment const &,::alignlib::CombinationMode const );
        
        bp::def( 
            "combineAlignment"
            , combineAlignment_function_type( &::alignlib::combineAlignment )
            , ( bp::arg("dest"), bp::arg("src1"), bp::arg("src2"), bp::arg("mode") ) );
    
    }

    { //::alignlib::copyAlignment
    
        typedef void ( *copyAlignment_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const &,::alignlib::HAlignment const &,::alignlib::CombinationMode const );
        
        bp::def( 
            "copyAlignment"
            , copyAlignment_function_type( &::alignlib::copyAlignment )
            , ( bp::arg("dest"), bp::arg("src"), bp::arg("filter"), bp::arg("mode") ) );
    
    }

    { //::alignlib::copyAlignment
    
        typedef void ( *copyAlignment_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const &,::alignlib::Position,::alignlib::Position,::alignlib::Position,::alignlib::Position,::alignlib::Diagonal,::alignlib::Diagonal );
        
        bp::def( 
            "copyAlignment"
            , copyAlignment_function_type( &::alignlib::copyAlignment )
            , ( bp::arg("dest"), bp::arg("src"), bp::arg("row_from")=(int)(-1), bp::arg("row_to")=(int)(-1), bp::arg("col_from")=(int)(-1), bp::arg("col_to")=(int)(-1), bp::arg("diagonal_from")=(long int)(-99999999), bp::arg("diagonal_to")=(long int)(99999999) ) );
    
    }

    { //::alignlib::copyAlignmentWithoutRegion
    
        typedef void ( *copyAlignmentWithoutRegion_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const &,::alignlib::Position,::alignlib::Position,::alignlib::Position,::alignlib::Position,::alignlib::Diagonal,::alignlib::Diagonal );
        
        bp::def( 
            "copyAlignmentWithoutRegion"
            , copyAlignmentWithoutRegion_function_type( &::alignlib::copyAlignmentWithoutRegion )
            , ( bp::arg("dest"), bp::arg("src"), bp::arg("row_from")=(int)(-1), bp::arg("row_to")=(int)(-1), bp::arg("col_from")=(int)(-1), bp::arg("col_to")=(int)(-1), bp::arg("diagonal_from")=(long int)(1), bp::arg("diagonal_to")=(long int)(0) ) );
    
    }

    { //::alignlib::copyMultipleAlignment
    
        typedef void ( *copyMultipleAlignment_function_type )( ::alignlib::HMultipleAlignment &,::alignlib::HMultipleAlignment const &,unsigned int,unsigned int );
        
        bp::def( 
            "copyMultipleAlignment"
            , copyMultipleAlignment_function_type( &::alignlib::copyMultipleAlignment )
            , ( bp::arg("dest"), bp::arg("src"), bp::arg("first_row")=(unsigned int)(0), bp::arg("last_row")=(unsigned int)(0) ) );
    
    }

    { //::alignlib::expandAlignment
    
        typedef void ( *expandAlignment_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment &,::alignlib::HAlignment const &,bool const,bool const,bool const,bool const,::alignlib::Position const,::alignlib::Position const );
        
        bp::def( 
            "expandAlignment"
            , expandAlignment_function_type( &::alignlib::expandAlignment )
            , ( bp::arg("map_row2combined"), bp::arg("map_col2combined"), bp::arg("src"), bp::arg("insert_gaps_row")=(bool const)(true), bp::arg("insert_gaps_col")=(bool const)(true), bp::arg("use_end_row")=(bool const)(false), bp::arg("use_end_col")=(bool const)(false), bp::arg("row_length")=(int const)(-1), bp::arg("col_length")=(int const)(-1) ) );
    
    }

    { //::alignlib::fillAlignmentGaps
    
        typedef void ( *fillAlignmentGaps_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignator const &,::alignlib::HAlignandum const &,::alignlib::HAlignandum const & );
        
        bp::def( 
            "fillAlignmentGaps"
            , fillAlignmentGaps_function_type( &::alignlib::fillAlignmentGaps )
            , ( bp::arg("dest"), bp::arg("alignator"), bp::arg("row"), bp::arg("col") ) );
    
    }

    { //::alignlib::fillAlignmentGaps
    
        typedef void ( *fillAlignmentGaps_function_type )( ::alignlib::HAlignment &,::alignlib::Position const );
        
        bp::def( 
            "fillAlignmentGaps"
            , fillAlignmentGaps_function_type( &::alignlib::fillAlignmentGaps )
            , ( bp::arg("dest"), bp::arg("max_length") ) );
    
    }

    { //::alignlib::fillAlignmentRepeatUnit
    
        typedef void ( *fillAlignmentRepeatUnit_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const &,::alignlib::Position const,bool const );
        
        bp::def( 
            "fillAlignmentRepeatUnit"
            , fillAlignmentRepeatUnit_function_type( &::alignlib::fillAlignmentRepeatUnit )
            , ( bp::arg("dest"), bp::arg("source"), bp::arg("first_row_residue")=(int const)(-1), bp::arg("skip_negative_ends")=(bool const)(false) ) );
    
    }

    { //::alignlib::fillDistanceMatrix
    
        typedef void ( *fillDistanceMatrix_function_type )( ::alignlib::HDistanceMatrix &,::alignlib::DistanceMatrixValue * );
        
        bp::def( 
            "fillDistanceMatrix"
            , fillDistanceMatrix_function_type( &::alignlib::fillDistanceMatrix )
            , ( bp::arg("dest"), bp::arg("source") ) );
    
    }

    { //::alignlib::fillMultipleAlignment
    
        typedef void ( *fillMultipleAlignment_function_type )( ::alignlib::HMultipleAlignment &,::std::string const &,int );
        
        bp::def( 
            "fillMultipleAlignment"
            , fillMultipleAlignment_function_type( &::alignlib::fillMultipleAlignment )
            , ( bp::arg("dst"), bp::arg("sequences"), bp::arg("nsequences") ) );
    
    }

    { //::alignlib::filterAlignmentRemovePairs
    
        typedef void ( *filterAlignmentRemovePairs_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const &,::alignlib::CombinationMode const );
        
        bp::def( 
            "filterAlignmentRemovePairs"
            , filterAlignmentRemovePairs_function_type( &::alignlib::filterAlignmentRemovePairs )
            , ( bp::arg("dest"), bp::arg("filter"), bp::arg("mode") ) );
    
    }

    { //::alignlib::filterAlignmentRemovePairwiseSorted
    
        typedef void ( *filterAlignmentRemovePairwiseSorted_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignment const &,::alignlib::CombinationMode const );
        
        bp::def( 
            "filterAlignmentRemovePairwiseSorted"
            , filterAlignmentRemovePairwiseSorted_function_type( &::alignlib::filterAlignmentRemovePairwiseSorted )
            , ( bp::arg("dest"), bp::arg("filter"), bp::arg("mode") ) );
    
    }

    { //::alignlib::flattenAlignment
    
        typedef void ( *flattenAlignment_function_type )( ::alignlib::HAlignment & );
        
        bp::def( 
            "flattenAlignment"
            , flattenAlignment_function_type( &::alignlib::flattenAlignment )
            , ( bp::arg("dest") ) );
    
    }

    { //::alignlib::getDefaultDistor
    
        typedef ::alignlib::HDistor ( *getDefaultDistor_function_type )(  );
        
        bp::def( 
            "getDefaultDistor"
            , getDefaultDistor_function_type( &::alignlib::getDefaultDistor ) );
    
    }

    { //::alignlib::getDefaultEncoder
    
        typedef ::alignlib::HEncoder ( *getDefaultEncoder_function_type )(  );
        
        bp::def( 
            "getDefaultEncoder"
            , getDefaultEncoder_function_type( &::alignlib::getDefaultEncoder ) );
    
    }

    { //::alignlib::getDefaultIterator2D
    
        typedef ::alignlib::HIterator2D ( *getDefaultIterator2D_function_type )(  );
        
        bp::def( 
            "getDefaultIterator2D"
            , getDefaultIterator2D_function_type( &::alignlib::getDefaultIterator2D ) );
    
    }

    { //::alignlib::getDefaultLogOddor
    
        typedef ::alignlib::HLogOddor ( *getDefaultLogOddor_function_type )(  );
        
        bp::def( 
            "getDefaultLogOddor"
            , getDefaultLogOddor_function_type( &::alignlib::getDefaultLogOddor ) );
    
    }

    { //::alignlib::getDefaultRegularizor
    
        typedef ::alignlib::HRegularizor ( *getDefaultRegularizor_function_type )(  );
        
        bp::def( 
            "getDefaultRegularizor"
            , getDefaultRegularizor_function_type( &::alignlib::getDefaultRegularizor ) );
    
    }

    { //::alignlib::getDefaultRenderer
    
        typedef ::alignlib::HRenderer ( *getDefaultRenderer_function_type )(  );
        
        bp::def( 
            "getDefaultRenderer"
            , getDefaultRenderer_function_type( &::alignlib::getDefaultRenderer ) );
    
    }

    { //::alignlib::getDefaultScorer
    
        typedef ::alignlib::HScorer ( *getDefaultScorer_function_type )(  );
        
        bp::def( 
            "getDefaultScorer"
            , getDefaultScorer_function_type( &::alignlib::getDefaultScorer ) );
    
    }

    { //::alignlib::getDefaultSubstitutionMatrix
    
        typedef ::alignlib::HSubstitutionMatrix ( *getDefaultSubstitutionMatrix_function_type )(  );
        
        bp::def( 
            "getDefaultSubstitutionMatrix"
            , getDefaultSubstitutionMatrix_function_type( &::alignlib::getDefaultSubstitutionMatrix ) );
    
    }

    { //::alignlib::getDefaultTreetor
    
        typedef ::alignlib::HTreetor ( *getDefaultTreetor_function_type )(  );
        
        bp::def( 
            "getDefaultTreetor"
            , getDefaultTreetor_function_type( &::alignlib::getDefaultTreetor ) );
    
    }

    { //::alignlib::getDefaultWeightor
    
        typedef ::alignlib::HWeightor ( *getDefaultWeightor_function_type )(  );
        
        bp::def( 
            "getDefaultWeightor"
            , getDefaultWeightor_function_type( &::alignlib::getDefaultWeightor ) );
    
    }

    { //::alignlib::getEncoder
    
        typedef ::alignlib::HEncoder const ( *getEncoder_function_type )( ::alignlib::AlphabetType const & );
        
        bp::def( 
            "getEncoder"
            , getEncoder_function_type( &::alignlib::getEncoder )
            , ( bp::arg("alphabet") ) );
    
    }

    { //::alignlib::hasAlignmentOverlap
    
        typedef bool ( *hasAlignmentOverlap_function_type )( ::alignlib::HAlignment const &,::alignlib::HAlignment const &,::alignlib::CombinationMode const,int );
        
        bp::def( 
            "hasAlignmentOverlap"
            , hasAlignmentOverlap_function_type( &::alignlib::hasAlignmentOverlap )
            , ( bp::arg("src1"), bp::arg("src2"), bp::arg("mode"), bp::arg("min_overlap")=(int)(1) ) );
    
    }

    { //::alignlib::loadSubstitutionMatrix
    
        typedef ::alignlib::HSubstitutionMatrix ( *loadSubstitutionMatrix_function_type )( ::std::istream &,::alignlib::HEncoder const & );
        
        bp::def( 
            "loadSubstitutionMatrix"
            , loadSubstitutionMatrix_function_type( &::alignlib::loadSubstitutionMatrix )
            , ( bp::arg("input"), bp::arg("translator") ) );
    
    }

    { //::alignlib::makeAlignatorDPFull
    
        typedef ::alignlib::HAlignator ( *makeAlignatorDPFull_function_type )( ::alignlib::AlignmentType,::alignlib::Score,::alignlib::Score,bool,bool,bool,bool );
        
        bp::def( 
            "makeAlignatorDPFull"
            , makeAlignatorDPFull_function_type( &::alignlib::makeAlignatorDPFull )
            , ( bp::arg("alignment_type"), bp::arg("gop"), bp::arg("gep"), bp::arg("penalize_row_left")=(bool)(false), bp::arg("penalize_row_right")=(bool)(false), bp::arg("penalize_col_left")=(bool)(false), bp::arg("penalize_col_right")=(bool)(false) ) );
    
    }

    { //::alignlib::makeAlignatorDots
    
        typedef ::alignlib::HAlignator ( *makeAlignatorDots_function_type )( ::alignlib::HAlignator const &,::alignlib::Score,::alignlib::Score );
        
        bp::def( 
            "makeAlignatorDots"
            , makeAlignatorDots_function_type( &::alignlib::makeAlignatorDots )
            , ( bp::arg("alignator"), bp::arg("gop"), bp::arg("gep") ) );
    
    }

    { //::alignlib::makeAlignatorDotsDiagonal
    
        typedef ::alignlib::HAlignator ( *makeAlignatorDotsDiagonal_function_type )( ::alignlib::HAlignator const &,::alignlib::Score,::alignlib::Score,::alignlib::Score,::alignlib::Score );
        
        bp::def( 
            "makeAlignatorDotsDiagonal"
            , makeAlignatorDotsDiagonal_function_type( &::alignlib::makeAlignatorDotsDiagonal )
            , ( bp::arg("alignator"), bp::arg("gop"), bp::arg("gep"), bp::arg("diagnal_gop")=0, bp::arg("diagonal_gep")=0 ) );
    
    }

    { //::alignlib::makeAlignatorFragments
    
        typedef ::alignlib::HAlignator ( *makeAlignatorFragments_function_type )( ::alignlib::Score,::alignlib::Score,::alignlib::HFragmentor const & );
        
        bp::def( 
            "makeAlignatorFragments"
            , makeAlignatorFragments_function_type( &::alignlib::makeAlignatorFragments )
            , ( bp::arg("gop"), bp::arg("gep"), bp::arg("fragmentor") ) );
    
    }

    { //::alignlib::makeAlignatorGroupies
    
        typedef ::alignlib::HAlignator ( *makeAlignatorGroupies_function_type )(  );
        
        bp::def( 
            "makeAlignatorGroupies"
            , makeAlignatorGroupies_function_type( &::alignlib::makeAlignatorGroupies ) );
    
    }

    { //::alignlib::makeAlignatorGroupies
    
        typedef ::alignlib::HAlignator ( *makeAlignatorGroupies_function_type )( ::alignlib::Position const,::alignlib::Position const,::alignlib::HAlignator const &,::alignlib::HAlignator const &,::alignlib::Score const &,::alignlib::Score const & );
        
        bp::def( 
            "makeAlignatorGroupies"
            , makeAlignatorGroupies_function_type( &::alignlib::makeAlignatorGroupies )
            , ( bp::arg("tube_size"), bp::arg("tuple_size"), bp::arg("alignator_dots"), bp::arg("alignator_gaps"), bp::arg("gop"), bp::arg("gep") ) );
    
    }

    { //::alignlib::makeAlignatorIdentity
    
        typedef ::alignlib::HAlignator ( *makeAlignatorIdentity_function_type )(  );
        
        bp::def( 
            "makeAlignatorIdentity"
            , makeAlignatorIdentity_function_type( &::alignlib::makeAlignatorIdentity ) );
    
    }

    { //::alignlib::makeAlignatorIterative
    
        typedef ::alignlib::HAlignator ( *makeAlignatorIterative_function_type )( ::alignlib::HAlignator const &,::alignlib::Score );
        
        bp::def( 
            "makeAlignatorIterative"
            , makeAlignatorIterative_function_type( &::alignlib::makeAlignatorIterative )
            , ( bp::arg("alignator"), bp::arg("min_score") ) );
    
    }

    { //::alignlib::makeAlignatorPrebuilt
    
        typedef ::alignlib::HAlignator ( *makeAlignatorPrebuilt_function_type )( ::alignlib::HAlignment const & );
        
        bp::def( 
            "makeAlignatorPrebuilt"
            , makeAlignatorPrebuilt_function_type( &::alignlib::makeAlignatorPrebuilt )
            , ( bp::arg("ali") ) );
    
    }

    { //::alignlib::makeAlignatorSimilarity
    
        typedef ::alignlib::HAlignator ( *makeAlignatorSimilarity_function_type )(  );
        
        bp::def( 
            "makeAlignatorSimilarity"
            , makeAlignatorSimilarity_function_type( &::alignlib::makeAlignatorSimilarity ) );
    
    }

    { //::alignlib::makeAlignatorTuples
    
        typedef ::alignlib::HAlignator ( *makeAlignatorTuples_function_type )( int );
        
        bp::def( 
            "makeAlignatorTuples"
            , makeAlignatorTuples_function_type( &::alignlib::makeAlignatorTuples )
            , ( bp::arg("ktuple")=(int)(3) ) );
    
    }

    { //::alignlib::makeAlignatum
    
        typedef ::alignlib::HAlignatum ( *makeAlignatum_function_type )(  );
        
        bp::def( 
            "makeAlignatum"
            , makeAlignatum_function_type( &::alignlib::makeAlignatum ) );
    
    }

    { //::alignlib::makeAlignatum
    
        typedef ::alignlib::HAlignatum ( *makeAlignatum_function_type )( ::alignlib::HAlignandum const &,::alignlib::Position const,::alignlib::Position const );
        
        bp::def( 
            "makeAlignatum"
            , makeAlignatum_function_type( &::alignlib::makeAlignatum )
            , ( bp::arg("src"), bp::arg("from")=(int const)(-1), bp::arg("to")=(int const)(-1) ) );
    
    }

    { //::alignlib::makeAlignatum
    
        typedef ::alignlib::HAlignatum ( *makeAlignatum_function_type )( ::alignlib::HAlignandum const &,::alignlib::HAlignment const &,::alignlib::Position const );
        
        bp::def( 
            "makeAlignatum"
            , makeAlignatum_function_type( &::alignlib::makeAlignatum )
            , ( bp::arg("src"), bp::arg("map_this2new"), bp::arg("max_length")=(int const)(0) ) );
    
    }

    { //::alignlib::makeAlignatum
    
        typedef ::alignlib::HAlignatum ( *makeAlignatum_function_type )( ::std::string const &,::alignlib::Position const,::alignlib::Position const );
        
        bp::def( 
            "makeAlignatum"
            , makeAlignatum_function_type( &::alignlib::makeAlignatum )
            , ( bp::arg("src"), bp::arg("from")=(int const)(-1), bp::arg("to")=(int const)(-1) ) );
    
    }

    { //::alignlib::makeAlignmentBlocks
    
        typedef ::alignlib::HAlignment ( *makeAlignmentBlocks_function_type )(  );
        
        bp::def( 
            "makeAlignmentBlocks"
            , makeAlignmentBlocks_function_type( &::alignlib::makeAlignmentBlocks ) );
    
    }

    { //::alignlib::makeAlignmentHash
    
        typedef ::alignlib::HAlignment ( *makeAlignmentHash_function_type )(  );
        
        bp::def( 
            "makeAlignmentHash"
            , makeAlignmentHash_function_type( &::alignlib::makeAlignmentHash ) );
    
    }

    { //::alignlib::makeAlignmentHashDiagonal
    
        typedef ::alignlib::HAlignment ( *makeAlignmentHashDiagonal_function_type )(  );
        
        bp::def( 
            "makeAlignmentHashDiagonal"
            , makeAlignmentHashDiagonal_function_type( &::alignlib::makeAlignmentHashDiagonal ) );
    
    }

    { //::alignlib::makeAlignmentMatrixDiagonal
    
        typedef ::alignlib::HAlignment ( *makeAlignmentMatrixDiagonal_function_type )(  );
        
        bp::def( 
            "makeAlignmentMatrixDiagonal"
            , makeAlignmentMatrixDiagonal_function_type( &::alignlib::makeAlignmentMatrixDiagonal ) );
    
    }

    { //::alignlib::makeAlignmentMatrixRow
    
        typedef ::alignlib::HAlignment ( *makeAlignmentMatrixRow_function_type )(  );
        
        bp::def( 
            "makeAlignmentMatrixRow"
            , makeAlignmentMatrixRow_function_type( &::alignlib::makeAlignmentMatrixRow ) );
    
    }

    { //::alignlib::makeAlignmentMatrixUnsorted
    
        typedef ::alignlib::HAlignment ( *makeAlignmentMatrixUnsorted_function_type )(  );
        
        bp::def( 
            "makeAlignmentMatrixUnsorted"
            , makeAlignmentMatrixUnsorted_function_type( &::alignlib::makeAlignmentMatrixUnsorted ) );
    
    }

    { //::alignlib::makeAlignmentSet
    
        typedef ::alignlib::HAlignment ( *makeAlignmentSet_function_type )(  );
        
        bp::def( 
            "makeAlignmentSet"
            , makeAlignmentSet_function_type( &::alignlib::makeAlignmentSet ) );
    
    }

    { //::alignlib::makeAlignmentSetCol
    
        typedef ::alignlib::HAlignment ( *makeAlignmentSetCol_function_type )(  );
        
        bp::def( 
            "makeAlignmentSetCol"
            , makeAlignmentSetCol_function_type( &::alignlib::makeAlignmentSetCol ) );
    
    }

    { //::alignlib::makeAlignmentVector
    
        typedef ::alignlib::HAlignment ( *makeAlignmentVector_function_type )(  );
        
        bp::def( 
            "makeAlignmentVector"
            , makeAlignmentVector_function_type( &::alignlib::makeAlignmentVector ) );
    
    }

    { //::alignlib::makeDistanceMatrixSymmetric
    
        typedef ::alignlib::HDistanceMatrix ( *makeDistanceMatrixSymmetric_function_type )( ::alignlib::DistanceMatrixSize,::alignlib::DistanceMatrixValue );
        
        bp::def( 
            "makeDistanceMatrixSymmetric"
            , makeDistanceMatrixSymmetric_function_type( &::alignlib::makeDistanceMatrixSymmetric )
            , ( bp::arg("size")=(long unsigned int)(0), bp::arg("default_value")=0 ) );
    
    }

    { //::alignlib::makeDistorClustal
    
        typedef ::alignlib::HDistor ( *makeDistorClustal_function_type )(  );
        
        bp::def( 
            "makeDistorClustal"
            , makeDistorClustal_function_type( &::alignlib::makeDistorClustal ) );
    
    }

    { //::alignlib::makeDistorDummy
    
        typedef ::alignlib::HDistor ( *makeDistorDummy_function_type )( ::alignlib::HDistanceMatrix const & );
        
        bp::def( 
            "makeDistorDummy"
            , makeDistorDummy_function_type( &::alignlib::makeDistorDummy )
            , ( bp::arg("matrix") ) );
    
    }

    { //::alignlib::makeDistorKimura
    
        typedef ::alignlib::HDistor ( *makeDistorKimura_function_type )(  );
        
        bp::def( 
            "makeDistorKimura"
            , makeDistorKimura_function_type( &::alignlib::makeDistorKimura ) );
    
    }

    { //::alignlib::makeEVDParameters
    
        typedef ::alignlib::EVDParameters * ( *makeEVDParameters_function_type )(  );
        
        bp::def( 
            "makeEVDParameters"
            , makeEVDParameters_function_type( &::alignlib::makeEVDParameters )
            , bp::return_value_policy< bp::manage_new_object >() );
    
    }

    { //::alignlib::makeEncoder
    
        typedef ::alignlib::HEncoder const ( *makeEncoder_function_type )( ::alignlib::AlphabetType const & );
        
        bp::def( 
            "makeEncoder"
            , makeEncoder_function_type( &::alignlib::makeEncoder )
            , ( bp::arg("alphabet") ) );
    
    }

    { //::alignlib::makeEntropyVector
    
        typedef ::alignlib::VectorDouble * ( *makeEntropyVector_function_type )( ::alignlib::CountMatrix const * );
        
        bp::def( 
            "makeEntropyVector"
            , makeEntropyVector_function_type( &::alignlib::makeEntropyVector )
            , ( bp::arg("src") )
            , bp::return_value_policy< bp::manage_new_object >() );
    
    }

    { //::alignlib::makeFragmentorDiagonals
    
        typedef ::alignlib::HFragmentor ( *makeFragmentorDiagonals_function_type )( ::alignlib::HAlignator const &,::alignlib::Score,::alignlib::Score );
        
        bp::def( 
            "makeFragmentorDiagonals"
            , makeFragmentorDiagonals_function_type( &::alignlib::makeFragmentorDiagonals )
            , ( bp::arg("alignator"), bp::arg("gop"), bp::arg("gep") ) );
    
    }

    { //::alignlib::makeFragmentorIterative
    
        typedef ::alignlib::HFragmentor ( *makeFragmentorIterative_function_type )( ::alignlib::HAlignment const &,::alignlib::Score,::alignlib::Score,::alignlib::Score );
        
        bp::def( 
            "makeFragmentorIterative"
            , makeFragmentorIterative_function_type( &::alignlib::makeFragmentorIterative )
            , ( bp::arg("dots"), bp::arg("min_score"), bp::arg("gop"), bp::arg("gep") ) );
    
    }

    { //::alignlib::makeFragmentorRepetitive
    
        typedef ::alignlib::HFragmentor ( *makeFragmentorRepetitive_function_type )( ::alignlib::HAlignator const &,::alignlib::Score );
        
        bp::def( 
            "makeFragmentorRepetitive"
            , makeFragmentorRepetitive_function_type( &::alignlib::makeFragmentorRepetitive )
            , ( bp::arg("alignator"), bp::arg("min_score") ) );
    
    }

    { //::alignlib::makeIterator2DBanded
    
        typedef ::alignlib::HIterator2D ( *makeIterator2DBanded_function_type )( ::alignlib::Diagonal const,::alignlib::Diagonal const );
        
        bp::def( 
            "makeIterator2DBanded"
            , makeIterator2DBanded_function_type( &::alignlib::makeIterator2DBanded )
            , ( bp::arg("lower_diagonal")=(long int const)(0), bp::arg("upper_diagonal")=(long int const)(0) ) );
    
    }

    { //::alignlib::makeIterator2DBanded
    
        typedef ::alignlib::HIterator2D ( *makeIterator2DBanded_function_type )( ::alignlib::HAlignandum const &,::alignlib::HAlignandum const &,::alignlib::Diagonal const,::alignlib::Diagonal const );
        
        bp::def( 
            "makeIterator2DBanded"
            , makeIterator2DBanded_function_type( &::alignlib::makeIterator2DBanded )
            , ( bp::arg("row"), bp::arg("col"), bp::arg("lower_diagonal")=(long int const)(0), bp::arg("upper_diagonal")=(long int const)(0) ) );
    
    }

    { //::alignlib::makeIterator2DFull
    
        typedef ::alignlib::HIterator2D ( *makeIterator2DFull_function_type )(  );
        
        bp::def( 
            "makeIterator2DFull"
            , makeIterator2DFull_function_type( &::alignlib::makeIterator2DFull ) );
    
    }

    { //::alignlib::makeIterator2DFull
    
        typedef ::alignlib::HIterator2D ( *makeIterator2DFull_function_type )( ::alignlib::HAlignandum const &,::alignlib::HAlignandum const & );
        
        bp::def( 
            "makeIterator2DFull"
            , makeIterator2DFull_function_type( &::alignlib::makeIterator2DFull )
            , ( bp::arg("row"), bp::arg("col") ) );
    
    }

    { //::alignlib::makeLogOddor
    
        typedef ::alignlib::HLogOddor ( *makeLogOddor_function_type )( ::alignlib::Score const &,::alignlib::Score const & );
        
        bp::def( 
            "makeLogOddor"
            , makeLogOddor_function_type( &::alignlib::makeLogOddor )
            , ( bp::arg("scale_factor")=1.0e+0, bp::arg("mask_value")=-10 ) );
    
    }

    { //::alignlib::makeLogOddorBackground
    
        typedef ::alignlib::HLogOddor ( *makeLogOddorBackground_function_type )( ::alignlib::HFrequencyVector const &,::alignlib::Score const &,::alignlib::Score const & );
        
        bp::def( 
            "makeLogOddorBackground"
            , makeLogOddorBackground_function_type( &::alignlib::makeLogOddorBackground )
            , ( bp::arg("frequencies"), bp::arg("scale_factor")=1.0e+0, bp::arg("mask_value")=-10 ) );
    
    }

    { //::alignlib::makeLogOddorGribskov
    
        typedef ::alignlib::HLogOddor ( *makeLogOddorGribskov_function_type )( ::alignlib::HSubstitutionMatrix const &,::alignlib::Score const &,::alignlib::Score const & );
        
        bp::def( 
            "makeLogOddorGribskov"
            , makeLogOddorGribskov_function_type( &::alignlib::makeLogOddorGribskov )
            , ( bp::arg("matrix"), bp::arg("scale_factor")=1.0e+0, bp::arg("mask_value")=-10 ) );
    
    }

    { //::alignlib::makeLogOddorUniform
    
        typedef ::alignlib::HLogOddor ( *makeLogOddorUniform_function_type )( ::alignlib::Score const &,::alignlib::Score const & );
        
        bp::def( 
            "makeLogOddorUniform"
            , makeLogOddorUniform_function_type( &::alignlib::makeLogOddorUniform )
            , ( bp::arg("scale_factor")=1.0e+0, bp::arg("mask_value")=-10 ) );
    
    }

    { //::alignlib::makeMultipleAlignment
    
        typedef ::alignlib::HMultipleAlignment ( *makeMultipleAlignment_function_type )(  );
        
        bp::def( 
            "makeMultipleAlignment"
            , makeMultipleAlignment_function_type( &::alignlib::makeMultipleAlignment ) );
    
    }

    { //::alignlib::makeMultipleAlignmentDots
    
        typedef ::alignlib::HMultipleAlignment ( *makeMultipleAlignmentDots_function_type )( bool,int );
        
        bp::def( 
            "makeMultipleAlignmentDots"
            , makeMultipleAlignmentDots_function_type( &::alignlib::makeMultipleAlignmentDots )
            , ( bp::arg("compress_unaligend_columns")=(bool)(true), bp::arg("max_insertion_length")=(int)(-1) ) );
    
    }

    { //::alignlib::makeMutatedSequence
    
        typedef ::alignlib::HAlignandum ( *makeMutatedSequence_function_type )( ::alignlib::HAlignandum,::alignlib::HMutationMatrix const &,long int const );
        
        bp::def( 
            "makeMutatedSequence"
            , makeMutatedSequence_function_type( &::alignlib::makeMutatedSequence )
            , ( bp::arg("src"), bp::arg("matrix"), bp::arg("seed")=(long int const)(0) ) );
    
    }

    { //::alignlib::makeNormalDistributionParameters
    
        typedef ::alignlib::NormalDistributionParameters * ( *makeNormalDistributionParameters_function_type )(  );
        
        bp::def( 
            "makeNormalDistributionParameters"
            , makeNormalDistributionParameters_function_type( &::alignlib::makeNormalDistributionParameters )
            , bp::return_value_policy< bp::manage_new_object >() );
    
    }

    { //::alignlib::makeProfile
    
        typedef ::alignlib::HAlignandum ( *makeProfile_function_type )( ::alignlib::HMultipleAlignment const & );
        
        bp::def( 
            "makeProfile"
            , makeProfile_function_type( &::alignlib::makeProfile )
            , ( bp::arg("mali") ) );
    
    }

    { //::alignlib::makeProfile
    
        typedef ::alignlib::HAlignandum ( *makeProfile_function_type )( ::alignlib::HMultipleAlignment const &,::alignlib::HEncoder const &,::alignlib::HWeightor const &,::alignlib::HRegularizor const &,::alignlib::HLogOddor const & );
        
        bp::def( 
            "makeProfile"
            , makeProfile_function_type( &::alignlib::makeProfile )
            , ( bp::arg("mali"), bp::arg("encoder"), bp::arg("weightor"), bp::arg("regularizor"), bp::arg("logoddor") ) );
    
    }

    { //::alignlib::makeProfile
    
        typedef ::alignlib::HAlignandum ( *makeProfile_function_type )( ::std::string const &,int );
        
        bp::def( 
            "makeProfile"
            , makeProfile_function_type( &::alignlib::makeProfile )
            , ( bp::arg("sequences"), bp::arg("nsequences") ) );
    
    }

    { //::alignlib::makeProfile
    
        typedef ::alignlib::HAlignandum ( *makeProfile_function_type )( ::std::string const &,int,::alignlib::HEncoder const &,::alignlib::HWeightor const &,::alignlib::HRegularizor const &,::alignlib::HLogOddor const & );
        
        bp::def( 
            "makeProfile"
            , makeProfile_function_type( &::alignlib::makeProfile )
            , ( bp::arg("sequences"), bp::arg("nsequences"), bp::arg("encoder"), bp::arg("weightor"), bp::arg("regularizor"), bp::arg("logoddor") ) );
    
    }

    { //::alignlib::makeProfile
    
        typedef ::alignlib::HAlignandum ( *makeProfile_function_type )( ::alignlib::Position const & );
        
        bp::def( 
            "makeProfile"
            , makeProfile_function_type( &::alignlib::makeProfile )
            , ( bp::arg("length") ) );
    
    }

    { //::alignlib::makeProfile
    
        typedef ::alignlib::HAlignandum ( *makeProfile_function_type )( ::alignlib::Position const &,::alignlib::HEncoder const &,::alignlib::HWeightor const &,::alignlib::HRegularizor const &,::alignlib::HLogOddor const & );
        
        bp::def( 
            "makeProfile"
            , makeProfile_function_type( &::alignlib::makeProfile )
            , ( bp::arg("length"), bp::arg("encoder"), bp::arg("weightor"), bp::arg("regularizor"), bp::arg("logoddor") ) );
    
    }

    { //::alignlib::makeProfile
    
        typedef ::alignlib::HAlignandum ( *makeProfile_function_type )(  );
        
        bp::def( 
            "makeProfile"
            , makeProfile_function_type( &::alignlib::makeProfile ) );
    
    }

    { //::alignlib::makeProfile
    
        typedef ::alignlib::HAlignandum ( *makeProfile_function_type )( ::alignlib::HEncoder const &,::alignlib::HWeightor const &,::alignlib::HRegularizor const &,::alignlib::HLogOddor const & );
        
        bp::def( 
            "makeProfile"
            , makeProfile_function_type( &::alignlib::makeProfile )
            , ( bp::arg("encoder"), bp::arg("weightor"), bp::arg("regularizor"), bp::arg("logoddor") ) );
    
    }

    { //::alignlib::makeRegularizor
    
        typedef ::alignlib::HRegularizor ( *makeRegularizor_function_type )(  );
        
        bp::def( 
            "makeRegularizor"
            , makeRegularizor_function_type( &::alignlib::makeRegularizor ) );
    
    }

    { //::alignlib::makeRegularizorDirichlet
    
        typedef ::alignlib::HRegularizor ( *makeRegularizorDirichlet_function_type )( ::alignlib::Count );
        
        bp::def( 
            "makeRegularizorDirichlet"
            , makeRegularizorDirichlet_function_type( &::alignlib::makeRegularizorDirichlet )
            , ( bp::arg("fade_cutoff")=0 ) );
    
    }

    { //::alignlib::makeRegularizorDirichletHash
    
        typedef ::alignlib::HRegularizor ( *makeRegularizorDirichletHash_function_type )( ::alignlib::Count );
        
        bp::def( 
            "makeRegularizorDirichletHash"
            , makeRegularizorDirichletHash_function_type( &::alignlib::makeRegularizorDirichletHash )
            , ( bp::arg("fade_cutoff")=0 ) );
    
    }

    { //::alignlib::makeRegularizorDirichletInterpolate
    
        typedef ::alignlib::HRegularizor ( *makeRegularizorDirichletInterpolate_function_type )( ::alignlib::Count );
        
        bp::def( 
            "makeRegularizorDirichletInterpolate"
            , makeRegularizorDirichletInterpolate_function_type( &::alignlib::makeRegularizorDirichletInterpolate )
            , ( bp::arg("fade_cutoff")=0 ) );
    
    }

    { //::alignlib::makeRegularizorDirichletPrecomputed
    
        typedef ::alignlib::HRegularizor ( *makeRegularizorDirichletPrecomputed_function_type )( ::alignlib::Count );
        
        bp::def( 
            "makeRegularizorDirichletPrecomputed"
            , makeRegularizorDirichletPrecomputed_function_type( &::alignlib::makeRegularizorDirichletPrecomputed )
            , ( bp::arg("fade_cutoff")=0 ) );
    
    }

    { //::alignlib::makeRegularizorPsiblast
    
        typedef ::alignlib::HRegularizor ( *makeRegularizorPsiblast_function_type )(  );
        
        bp::def( 
            "makeRegularizorPsiblast"
            , makeRegularizorPsiblast_function_type( &::alignlib::makeRegularizorPsiblast ) );
    
    }

    { //::alignlib::makeRegularizorTatusov
    
        typedef ::alignlib::HRegularizor ( *makeRegularizorTatusov_function_type )( ::alignlib::HSubstitutionMatrix const &,::alignlib::HFrequencyVector const &,double const &,double const & );
        
        bp::def( 
            "makeRegularizorTatusov"
            , makeRegularizorTatusov_function_type( &::alignlib::makeRegularizorTatusov )
            , ( bp::arg("matrix"), bp::arg("background"), bp::arg("beta"), bp::arg("lambda") ) );
    
    }

    { //::alignlib::makeRenderer
    
        typedef ::alignlib::HRenderer ( *makeRenderer_function_type )(  );
        
        bp::def( 
            "makeRenderer"
            , makeRenderer_function_type( &::alignlib::makeRenderer ) );
    
    }

    { //::alignlib::makeRendererMView
    
        typedef ::alignlib::HRenderer ( *makeRendererMView_function_type )( ::std::string const & );
        
        bp::def( 
            "makeRendererMView"
            , makeRendererMView_function_type( &::alignlib::makeRendererMView )
            , ( bp::arg("consensus") ) );
    
    }

    { //::alignlib::makeScorer
    
        typedef ::alignlib::HScorer ( *makeScorer_function_type )(  );
        
        bp::def( 
            "makeScorer"
            , makeScorer_function_type( &::alignlib::makeScorer ) );
    
    }

    { //::alignlib::makeScorer
    
        typedef ::alignlib::HScorer ( *makeScorer_function_type )( ::alignlib::HAlignandum const &,::alignlib::HAlignandum const &,::alignlib::HSubstitutionMatrix const & );
        
        bp::def( 
            "makeScorer"
            , makeScorer_function_type( &::alignlib::makeScorer )
            , ( bp::arg("row"), bp::arg("col"), bp::arg("matrix") ) );
    
    }

    { //::alignlib::makeScorer
    
        typedef ::alignlib::HScorer ( *makeScorer_function_type )( ::alignlib::HAlignandum const &,::alignlib::HAlignandum const & );
        
        bp::def( 
            "makeScorer"
            , makeScorer_function_type( &::alignlib::makeScorer )
            , ( bp::arg("row"), bp::arg("col") ) );
    
    }

    { //::alignlib::makeSequence
    
        typedef ::alignlib::HAlignandum ( *makeSequence_function_type )( ::std::string const &,::alignlib::HEncoder const & );
        
        bp::def( 
            "makeSequence"
            , makeSequence_function_type( &::alignlib::makeSequence )
            , ( bp::arg("sequence"), bp::arg("encoder") ) );
    
    }

    { //::alignlib::makeSequence
    
        typedef ::alignlib::HAlignandum ( *makeSequence_function_type )( ::std::string const & );
        
        bp::def( 
            "makeSequence"
            , makeSequence_function_type( &::alignlib::makeSequence )
            , ( bp::arg("sequence") ) );
    
    }

    { //::alignlib::makeSequence
    
        typedef ::alignlib::HAlignandum ( *makeSequence_function_type )( char const *,::alignlib::HEncoder const & );
        
        bp::def( 
            "makeSequence"
            , makeSequence_function_type( &::alignlib::makeSequence )
            , ( bp::arg("sequence"), bp::arg("encoder") ) );
    
    }

    { //::alignlib::makeSequence
    
        typedef ::alignlib::HAlignandum ( *makeSequence_function_type )( char const * );
        
        bp::def( 
            "makeSequence"
            , makeSequence_function_type( &::alignlib::makeSequence )
            , ( bp::arg("sequence") ) );
    
    }

    { //::alignlib::makeSubstitutionMatrix
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrix_function_type )( ::alignlib::ScoreVector const &,int,int );
        
        bp::def( 
            "makeSubstitutionMatrix"
            , makeSubstitutionMatrix_function_type( &::alignlib::makeSubstitutionMatrix )
            , ( bp::arg("scores"), bp::arg("nrows"), bp::arg("ncols") ) );
    
    }

    { //::alignlib::makeSubstitutionMatrix
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrix_function_type )( int,::alignlib::Score const,::alignlib::Score const );
        
        bp::def( 
            "makeSubstitutionMatrix"
            , makeSubstitutionMatrix_function_type( &::alignlib::makeSubstitutionMatrix )
            , ( bp::arg("alphabet_size"), bp::arg("match")=1, bp::arg("mismatch")=-1 ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixBlosum50
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixBlosum50_function_type )( ::alignlib::HEncoder const & );
        
        bp::def( 
            "makeSubstitutionMatrixBlosum50"
            , makeSubstitutionMatrixBlosum50_function_type( &::alignlib::makeSubstitutionMatrixBlosum50 )
            , ( bp::arg("encoder") ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixBlosum50
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixBlosum50_function_type )(  );
        
        bp::def( 
            "makeSubstitutionMatrixBlosum50"
            , makeSubstitutionMatrixBlosum50_function_type( &::alignlib::makeSubstitutionMatrixBlosum50 ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixBlosum62
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixBlosum62_function_type )( ::alignlib::HEncoder const & );
        
        bp::def( 
            "makeSubstitutionMatrixBlosum62"
            , makeSubstitutionMatrixBlosum62_function_type( &::alignlib::makeSubstitutionMatrixBlosum62 )
            , ( bp::arg("encoder") ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixBlosum62
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixBlosum62_function_type )(  );
        
        bp::def( 
            "makeSubstitutionMatrixBlosum62"
            , makeSubstitutionMatrixBlosum62_function_type( &::alignlib::makeSubstitutionMatrixBlosum62 ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixPam120
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixPam120_function_type )( ::alignlib::HEncoder const & );
        
        bp::def( 
            "makeSubstitutionMatrixPam120"
            , makeSubstitutionMatrixPam120_function_type( &::alignlib::makeSubstitutionMatrixPam120 )
            , ( bp::arg("encoder") ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixPam120
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixPam120_function_type )(  );
        
        bp::def( 
            "makeSubstitutionMatrixPam120"
            , makeSubstitutionMatrixPam120_function_type( &::alignlib::makeSubstitutionMatrixPam120 ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixPam250
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixPam250_function_type )( ::alignlib::HEncoder const & );
        
        bp::def( 
            "makeSubstitutionMatrixPam250"
            , makeSubstitutionMatrixPam250_function_type( &::alignlib::makeSubstitutionMatrixPam250 )
            , ( bp::arg("encoder") ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixPam250
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixPam250_function_type )(  );
        
        bp::def( 
            "makeSubstitutionMatrixPam250"
            , makeSubstitutionMatrixPam250_function_type( &::alignlib::makeSubstitutionMatrixPam250 ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixPam30
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixPam30_function_type )( ::alignlib::HEncoder const & );
        
        bp::def( 
            "makeSubstitutionMatrixPam30"
            , makeSubstitutionMatrixPam30_function_type( &::alignlib::makeSubstitutionMatrixPam30 )
            , ( bp::arg("encoder") ) );
    
    }

    { //::alignlib::makeSubstitutionMatrixPam30
    
        typedef ::alignlib::HSubstitutionMatrix ( *makeSubstitutionMatrixPam30_function_type )(  );
        
        bp::def( 
            "makeSubstitutionMatrixPam30"
            , makeSubstitutionMatrixPam30_function_type( &::alignlib::makeSubstitutionMatrixPam30 ) );
    
    }

    { //::alignlib::makeTree
    
        typedef ::alignlib::HTree ( *makeTree_function_type )( ::alignlib::Node const );
        
        bp::def( 
            "makeTree"
            , makeTree_function_type( &::alignlib::makeTree )
            , ( bp::arg("num_leaves")=(long unsigned int const)(0) ) );
    
    }

    { //::alignlib::makeTreetorDistanceLinkage
    
        typedef ::alignlib::HTreetor ( *makeTreetorDistanceLinkage_function_type )( ::alignlib::HDistor const &,::alignlib::LinkageType );
        
        bp::def( 
            "makeTreetorDistanceLinkage"
            , makeTreetorDistanceLinkage_function_type( &::alignlib::makeTreetorDistanceLinkage )
            , ( bp::arg("distor"), bp::arg("method")=::alignlib::UPGMA ) );
    
    }

    { //::alignlib::makeTreetorDistanceNJ
    
        typedef ::alignlib::HTreetor ( *makeTreetorDistanceNJ_function_type )( ::alignlib::HDistor const & );
        
        bp::def( 
            "makeTreetorDistanceNJ"
            , makeTreetorDistanceNJ_function_type( &::alignlib::makeTreetorDistanceNJ )
            , ( bp::arg("distor") ) );
    
    }

    { //::alignlib::makeWeightor
    
        typedef ::alignlib::HWeightor ( *makeWeightor_function_type )(  );
        
        bp::def( 
            "makeWeightor"
            , makeWeightor_function_type( &::alignlib::makeWeightor ) );
    
    }

    { //::alignlib::makeWeightorHenikoff
    
        typedef ::alignlib::HWeightor ( *makeWeightorHenikoff_function_type )( bool const );
        
        bp::def( 
            "makeWeightorHenikoff"
            , makeWeightorHenikoff_function_type( &::alignlib::makeWeightorHenikoff )
            , ( bp::arg("rescale_counts")=(bool const)(false) ) );
    
    }

    { //::alignlib::pruneAlignment
    
        typedef void ( *pruneAlignment_function_type )( ::alignlib::HAlignment &,::alignlib::Score const,::alignlib::Score const );
        
        bp::def( 
            "pruneAlignment"
            , pruneAlignment_function_type( &::alignlib::pruneAlignment )
            , ( bp::arg("src"), bp::arg("gop"), bp::arg("gep") ) );
    
    }

    { //::alignlib::removeFragments
    
        typedef void ( *removeFragments_function_type )( ::alignlib::HAlignment &,unsigned int const,unsigned int const,::alignlib::Position const );
        
        bp::def( 
            "removeFragments"
            , removeFragments_function_type( &::alignlib::removeFragments )
            , ( bp::arg("dest"), bp::arg("fragment_length"), bp::arg("min_gap_length"), bp::arg("row_length")=(int const)(-1) ) );
    
    }

    { //::alignlib::rescoreAlignment
    
        typedef void ( *rescoreAlignment_function_type )( ::alignlib::HAlignment &,::alignlib::Score const );
        
        bp::def( 
            "rescoreAlignment"
            , rescoreAlignment_function_type( &::alignlib::rescoreAlignment )
            , ( bp::arg("dest"), bp::arg("score")=0 ) );
    
    }

    { //::alignlib::rescoreAlignment
    
        typedef void ( *rescoreAlignment_function_type )( ::alignlib::HAlignment &,::alignlib::HAlignandum const &,::alignlib::HAlignandum const &,::alignlib::HScorer const & );
        
        bp::def( 
            "rescoreAlignment"
            , rescoreAlignment_function_type( &::alignlib::rescoreAlignment )
            , ( bp::arg("dest"), bp::arg("row"), bp::arg("col"), bp::arg("scorer") ) );
    
    }

    { //::alignlib::rescoreFragmentsNumberGaps
    
        typedef void ( *rescoreFragmentsNumberGaps_function_type )( ::alignlib::HFragmentVector &,::alignlib::Score,::alignlib::Score );
        
        bp::def( 
            "rescoreFragmentsNumberGaps"
            , rescoreFragmentsNumberGaps_function_type( &::alignlib::rescoreFragmentsNumberGaps )
            , ( bp::arg("fragments"), bp::arg("gop")=0, bp::arg("gep")=0 ) );
    
    }

    { //::alignlib::setDefaultDistor
    
        typedef void ( *setDefaultDistor_function_type )( ::alignlib::HDistor const & );
        
        bp::def( 
            "setDefaultDistor"
            , setDefaultDistor_function_type( &::alignlib::setDefaultDistor )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::setDefaultEncoder
    
        typedef void ( *setDefaultEncoder_function_type )( ::alignlib::HEncoder const & );
        
        bp::def( 
            "setDefaultEncoder"
            , setDefaultEncoder_function_type( &::alignlib::setDefaultEncoder )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::setDefaultIterator2D
    
        typedef void ( *setDefaultIterator2D_function_type )( ::alignlib::HIterator2D const & );
        
        bp::def( 
            "setDefaultIterator2D"
            , setDefaultIterator2D_function_type( &::alignlib::setDefaultIterator2D )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::setDefaultLogOddor
    
        typedef void ( *setDefaultLogOddor_function_type )( ::alignlib::HLogOddor const & );
        
        bp::def( 
            "setDefaultLogOddor"
            , setDefaultLogOddor_function_type( &::alignlib::setDefaultLogOddor )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::setDefaultRegularizor
    
        typedef void ( *setDefaultRegularizor_function_type )( ::alignlib::HRegularizor const & );
        
        bp::def( 
            "setDefaultRegularizor"
            , setDefaultRegularizor_function_type( &::alignlib::setDefaultRegularizor )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::setDefaultRenderer
    
        typedef void ( *setDefaultRenderer_function_type )( ::alignlib::HRenderer const & );
        
        bp::def( 
            "setDefaultRenderer"
            , setDefaultRenderer_function_type( &::alignlib::setDefaultRenderer )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::setDefaultScorer
    
        typedef void ( *setDefaultScorer_function_type )( ::alignlib::HScorer const & );
        
        bp::def( 
            "setDefaultScorer"
            , setDefaultScorer_function_type( &::alignlib::setDefaultScorer )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::setDefaultSubstitutionMatrix
    
        typedef void ( *setDefaultSubstitutionMatrix_function_type )( ::alignlib::HSubstitutionMatrix const & );
        
        bp::def( 
            "setDefaultSubstitutionMatrix"
            , setDefaultSubstitutionMatrix_function_type( &::alignlib::setDefaultSubstitutionMatrix )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::setDefaultTreetor
    
        typedef void ( *setDefaultTreetor_function_type )( ::alignlib::HTreetor const & );
        
        bp::def( 
            "setDefaultTreetor"
            , setDefaultTreetor_function_type( &::alignlib::setDefaultTreetor )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::setDefaultWeightor
    
        typedef void ( *setDefaultWeightor_function_type )( ::alignlib::HWeightor const & );
        
        bp::def( 
            "setDefaultWeightor"
            , setDefaultWeightor_function_type( &::alignlib::setDefaultWeightor )
            , ( bp::arg("arg0") ) );
    
    }

    { //::alignlib::splitAlignment
    
        typedef ::alignlib::HFragmentVector ( *splitAlignment_function_type )( ::alignlib::HAlignment const &,::alignlib::HAlignment const &,::alignlib::CombinationMode const );
        
        bp::def( 
            "splitAlignment"
            , splitAlignment_function_type( &::alignlib::splitAlignment )
            , ( bp::arg("src1"), bp::arg("src2"), bp::arg("mode") ) );
    
    }

    { //::alignlib::splitAlignment
    
        typedef ::alignlib::HFragmentVector ( *splitAlignment_function_type )( ::alignlib::HAlignment const &,int const,bool,bool );
        
        bp::def( 
            "splitAlignment"
            , splitAlignment_function_type( &::alignlib::splitAlignment )
            , ( bp::arg("src"), bp::arg("max_gap_width"), bp::arg("split_row")=(bool)(true), bp::arg("split_col")=(bool)(true) ) );
    
    }

    { //::alignlib::writeFragments
    
        typedef void ( *writeFragments_function_type )( ::std::ostream &,::alignlib::HFragmentVector const & );
        
        bp::def( 
            "writeFragments"
            , writeFragments_function_type( &::alignlib::writeFragments )
            , ( bp::arg("output"), bp::arg("fragments") ) );
    
    }

    bp::def( "loadAlignandum", wrapper_for_load_Alignandum );

    bp::def( "loadEncoder", wrapper_for_load_Encoder );

    { //::std::vector<HAlignment, std::allocator<HAlignment> >
            typedef bp::class_< std::vector<alignlib::HAlignment, std::allocator<alignlib::HAlignment> > > FragmentVector_exposer_t;
            FragmentVector_exposer_t FragmentVector_exposer = FragmentVector_exposer_t( "FragmentVector" );
            bp::scope FragmentVector_scope( FragmentVector_exposer );
            FragmentVector_exposer.def( bp::vector_indexing_suite< ::std::vector<alignlib::HAlignment, std::allocator<alignlib::HAlignment> >, true >() );
            }
    
            bp::register_ptr_to_python< boost::shared_ptr<alignlib::FragmentVector> >();

    { //::alignlib::writeNewHampshire
    
        typedef void ( *writeNewHampshire_function_type )( ::std::ostream &,::alignlib::HTree const &,::alignlib::Labels const * );
        
        bp::def( 
            "writeNewHampshire"
            , writeNewHampshire_function_type( &::alignlib::writeNewHampshire )
            , ( bp::arg("output"), bp::arg("tree"), bp::arg("labels")=bp::object() ) );
    
    }
}
